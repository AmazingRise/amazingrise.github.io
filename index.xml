<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>左手的世界</title><link>https://risehere.net/</link><description>Recent content on 左手的世界</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><copyright>Rise. 本站遵循 CC-BY-NC 4.0 协议</copyright><lastBuildDate>Fri, 25 Oct 2019 23:46:42 +0000</lastBuildDate><atom:link href="https://risehere.net/index.xml" rel="self" type="application/rss+xml"/><item><title>我突然不想写代码了</title><link>https://risehere.net/posts/one-day-no-more-code/</link><pubDate>Mon, 14 Nov 2022 00:07:18 +0800</pubDate><guid>https://risehere.net/posts/one-day-no-more-code/</guid><description>左手的世界 https://risehere.net/posts/one-day-no-more-code/ -&lt;p>yes&lt;/p>
- https://risehere.net/posts/one-day-no-more-code/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>如何把 C 语言移植到 RISC-V 裸机上</title><link>https://risehere.net/posts/running-c-program-on-bare-machine/</link><pubDate>Thu, 14 Jan 2021 20:04:40 +0800</pubDate><guid>https://risehere.net/posts/running-c-program-on-bare-machine/</guid><description>左手的世界 https://risehere.net/posts/running-c-program-on-bare-machine/ -&lt;h1 id="前言">前言&lt;/h1>
&lt;p>之前用 Verilog 模拟实现了一个简易的 RISC-V 处理器（RV32I 指令集）。为了跑测试程序，我们的这个处理器自然也要带上存储器，所以实际上它是一台简单的计算机。为了简化设计，这台计算机基于&lt;a href="https://en.wikipedia.org/wiki/Harvard_architecture">哈佛架构&lt;/a>。简单来说，就是数据和指令分开存储，机器读取。想要运行程序，就要把汇编代码编译出来，烧写到我们的 ROM 上。&lt;/p>
&lt;p>为了方便调试，我对 CPU 进行了一些简单的约定：&lt;/p>
&lt;ul>
&lt;li>外界可以通过8个二进制开关对计算机输入一个值。这个值可以在内存地址 &lt;code>0x40000000&lt;/code> 处读取到。&lt;/li>
&lt;li>8个 LED 灯与内存地址 &lt;code>0x80000000&lt;/code> 上的值相绑定。也就是这里的值，将会以二进制的形式显示在 8 个 LED 灯上。&lt;/li>
&lt;li>处理器加电时会产生 RST 信号。寄存器收到 RST 信号时，所有的寄存器将会被置零。这个约定是为了方便初始化寄存器。&lt;/li>
&lt;/ul>
&lt;p>我们的目标是在我们的 RISC-V 计算机上成功运行一个 Fibonacci 数运算程序。流程是：&lt;/p>
&lt;ol>
&lt;li>拨动8个开关，作为输入。&lt;/li>
&lt;li>给板子加电。&lt;/li>
&lt;li>Fibonacci 运算程序从 &lt;code>0x40000000&lt;/code> 处读取8位开关的输入。&lt;/li>
&lt;li>Fibonacci 运算程序进行计算。&lt;/li>
&lt;li>Fibonacci 运算程序将结果写到 &lt;code>0x80000000&lt;/code> 这个地址上。&lt;/li>
&lt;li>8位 LED 灯以二进制的形式显示&lt;code>0x80000000&lt;/code> 处的内容。&lt;/li>
&lt;/ol>
&lt;p>用汇编实现这个程序很轻松。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">&lt;span style="color:#50fa7b">.globl&lt;/span> __start
.globl end
&lt;span style="color:#50fa7b">.text&lt;/span>
&lt;span style="color:#8be9fd;font-style:italic">__start:&lt;/span>
&lt;span style="color:#50fa7b">lui&lt;/span> x1,&lt;span style="color:#bd93f9">0x0&lt;/span>&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> lw x10,&lt;span style="color:#bd93f9">0x40000000&lt;/span>(x0)&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>
addi x2,x0,&lt;span style="color:#bd93f9">3&lt;/span>&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> addi x5,x0,&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> blt x10,x2,end&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>
addi x1,x1,&lt;span style="color:#bd93f9">12&lt;/span>&lt;span style="color:#6272a4">; # init
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> addi x6,x0,&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> sw x6,-&lt;span style="color:#bd93f9">8&lt;/span>(x1)&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> sw x6,-&lt;span style="color:#bd93f9">4&lt;/span>(x1)&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>main:
&lt;span style="color:#50fa7b">lw&lt;/span> x3,-&lt;span style="color:#bd93f9">8&lt;/span>(x1)&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> lw x4,-&lt;span style="color:#bd93f9">4&lt;/span>(x1)&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> add x5,x3,x4&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> sw x5,&lt;span style="color:#bd93f9">0&lt;/span>(x1)&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> beq x2,x10,end&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> addi x1,x1,&lt;span style="color:#bd93f9">4&lt;/span>&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> addi x2,x2,&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> beq x0,x0,main&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>end:
&lt;span style="color:#50fa7b">sw&lt;/span> x5,&lt;span style="color:#bd93f9">0x80000000&lt;/span>(x0)&lt;span style="color:#6272a4">;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么，我们是否可以将 C 语言程序移植到这个平台上呢？&lt;/p>
&lt;p>还是交叉编译那一套&amp;ndash;借助 RISC-V 交叉编译工具链，我们可以将 C 语言程序移植到我们造的计算机上。&lt;/p>
&lt;h1 id="正文">正文&lt;/h1>
&lt;h2 id="获得工具链">获得工具链&lt;/h2>
&lt;p>我们注意到，RISC-V 工具链分为两个版本：&lt;/p>
&lt;ul>
&lt;li>Newlib 版本，所有的命令开头是&lt;code>riscv64-unknown-elf-&lt;/code>。&lt;/li>
&lt;li>Linux 版本，所有的命令开头是&lt;code>riscv64-linux-gnu-&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>那么我们应该选哪个呢？经过试验两者产生的机器码（.text部分）并无区别，但我建议选择 Newlib 版本的工具链。具体原因将在&lt;a href="#faq">后面&lt;/a>说。&lt;/p>
&lt;p>Arch Linux 用户们可以&lt;strong>直接在 AUR 上获取&lt;/strong> &lt;code>riscv64-unknown-elf-gcc&lt;/code> 和 &lt;code>riscv64-unknown-elf-newlib&lt;/code> 这两个包。安装后你将获得两个版本的工具链。&lt;/p>
&lt;p>你可以从源代码自行构建 &amp;ndash; &lt;a href="https://github.com/riscv/riscv-gnu-toolchain">RISC-V GNU Compiler Toolchain&lt;/a>。&lt;/p>
&lt;h2 id="主程序的编写">主程序的编写&lt;/h2>
&lt;p>利用 C 语言的指针操作，我们可以直接读写内存。下面是实现 Fibonacci 数计算的代码：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>(){
&lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">*&lt;/span> n; &lt;span style="color:#6272a4">// Input
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> n &lt;span style="color:#ff79c6">=&lt;/span> (&lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">*&lt;/span>) &lt;span style="color:#bd93f9">0x40000000&lt;/span>; &lt;span style="color:#6272a4">// Point input to 0x40000000
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> n1 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>;
&lt;span style="color:#8be9fd">int&lt;/span> n2 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>;
&lt;span style="color:#8be9fd">int&lt;/span> n3;
&lt;span style="color:#8be9fd">int&lt;/span> i;
&lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>; i &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> (&lt;span style="color:#ff79c6">*&lt;/span>n) &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>; &lt;span style="color:#ff79c6">++&lt;/span>i){
n3 &lt;span style="color:#ff79c6">=&lt;/span> n1 &lt;span style="color:#ff79c6">+&lt;/span> n2;
n1 &lt;span style="color:#ff79c6">=&lt;/span> n2;
n2 &lt;span style="color:#ff79c6">=&lt;/span> n3;
}
&lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">*&lt;/span> result; &lt;span style="color:#6272a4">// Output
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> result &lt;span style="color:#ff79c6">=&lt;/span> (&lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">*&lt;/span>) &lt;span style="color:#bd93f9">0x80000000&lt;/span>; &lt;span style="color:#6272a4">// Point output to 0x40000000
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">*&lt;/span>result &lt;span style="color:#ff79c6">=&lt;/span> n3; &lt;span style="color:#6272a4">// Write result to 0x40000000
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">for&lt;/span>(;;){
} &lt;span style="color:#6272a4">// Endless loop, to hold on the result
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>我们现在在为裸机编写 C 语言程序，不能引用标准库中的函数，如 printf。&lt;/li>
&lt;li>由于内存紧张，我们尽量不要用递归。&lt;/li>
&lt;li>最后要写一个死循环，相当于停机。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>现在我们的主程序已经编写完毕了，下面我们要编译它。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">riscv64-unknown-elf-gcc -c -nostdlib -march&lt;span style="color:#ff79c6">=&lt;/span>rv32i -mabi&lt;span style="color:#ff79c6">=&lt;/span>ilp32 main.c -o main.o
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>-c&lt;/code>选项是编译、汇编到目标代码，不进行链接。&lt;/li>
&lt;li>&lt;code>-nostdlib&lt;/code>告诉编译器不要把标准库编译进去。&lt;/li>
&lt;li>&lt;code>-march=rv32i -mabi=ilp32&lt;/code> 用于指定指令集架构和 ABI。&lt;/li>
&lt;/ul>
&lt;p>编译后，我们可以得到 &lt;code>main.o&lt;/code>，它是一个 ELF 文件。我们只需要 &lt;code>.text&lt;/code> 部分的机器指令，所以用 &lt;code>objcopy&lt;/code> 对它进行处理：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">riscv64-unknown-elf-objcopy -O binary -j .text main.o main.bin
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>-O binary&lt;/code> 选项用于输出纯二进制文件。&lt;/li>
&lt;li>&lt;code>-j .text&lt;/code> 是告诉它只保留 &lt;code>.text&lt;/code> 部分。&lt;/li>
&lt;/ul>
&lt;p>经过处理，生成的二进制文件只含有机器指令。但此时的程序并不能直接运行。我们用 &lt;code>objdump&lt;/code> 进行反编译，看看生成的机器码是怎么样的：&lt;/p>
&lt;pre>&lt;code>➜ riscv64-unknown-elf-objdump -D -b binary main.bin -mriscv
main.bin: file format binary
Disassembly of section .data:
0000000000000000 &amp;lt;.data&amp;gt;:
0: fd010113 addi sp,sp,-48
4: 02812623 sw s0,44(sp)
8: 03010413 addi s0,sp,48
c: 400007b7 lui a5,0x40000
...
&lt;/code>&lt;/pre>&lt;p>&lt;code>lui a5,0x40000&lt;/code> 显然对应我们代码的开头（将变量 n 指向 &lt;code>0x40000000&lt;/code>）。GCC在前面加了三条指令，而第一句就将&lt;code>sp&lt;/code>寄存器减去了48。&lt;code>sp&lt;/code>为负，程序肯定不能正常运行。&lt;/p>
&lt;blockquote>
&lt;p>这三条指令用于设置 Stack Pointer(&lt;code>sp&lt;/code>) 和 Frame Pointer(&lt;code>s0&lt;/code>)。&lt;/p>
&lt;/blockquote>
&lt;p>所以，在运行 C 语言程序之前，我们需要给 &lt;code>sp&lt;/code> 寄存器设置一个初始值。这个不难，一行汇编代码就能搞定：&lt;code>lui sp, 0x10&lt;/code>。但是这行代码怎么放，又是一个问题。&lt;/p>
&lt;h2 id="将汇编语句连接到主程序">将汇编语句连接到主程序&lt;/h2>
&lt;p>下面我们将探索三种思路：&lt;/p>
&lt;ul>
&lt;li>内联汇编&lt;/li>
&lt;li>直接用 cat 合并两个二进制文件&lt;/li>
&lt;li>用 ld 连接汇编和 C 语言程序&lt;/li>
&lt;/ul>
&lt;h3 id="内联汇编">内联汇编？&lt;/h3>
&lt;p>我们可不可以在 C 语言里内联汇编实现对 &lt;code>sp&lt;/code> 的初始化呢？答案是&lt;strong>否定&lt;/strong>的。我们在 main 的第一行加一句内联汇编：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>(){
&lt;span style="color:#ff79c6">asm&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;lui sp,0x10&amp;#34;&lt;/span>);
&lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">*&lt;/span> n; &lt;span style="color:#6272a4">// Input
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> n &lt;span style="color:#ff79c6">=&lt;/span> (&lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">*&lt;/span>) &lt;span style="color:#bd93f9">0x40000000&lt;/span>; &lt;span style="color:#6272a4">// Point input to 0x40000000
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后尝试反编译，看看这句话被加到了哪里：&lt;/p>
&lt;pre>&lt;code>➜ riscv64-unknown-elf-objdump -D -b binary main.bin -mriscv
main.bin: file format binary
Disassembly of section .data:
0000000000000000 &amp;lt;.data&amp;gt;:
0: fd010113 addi sp,sp,-48
4: 02812623 sw s0,44(sp)
8: 03010413 addi s0,sp,48
c: 00010137 lui sp,0x10
10: 400007b7 lui a5,0x40000
...
&lt;/code>&lt;/pre>&lt;p>可以看到，内联汇编被放在了&lt;code>0xc&lt;/code>的位置，在设置栈顶指针之后才被调用。很显然这是&lt;strong>马后炮&lt;/strong>。我们要换一种方法。&lt;/p>
&lt;h3 id="方法1-用-cat-合并">方法1 用 cat 合并&lt;/h3>
&lt;p>我们先写一个汇编文件，命名为&lt;code>init.s&lt;/code>。内容如下&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">&lt;span style="color:#50fa7b">lui&lt;/span> sp, &lt;span style="color:#bd93f9">0x10&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后我们用相同的方法编译它，并把它剪切成纯二进制格式：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">riscv64-unknown-elf-gcc -c -nostdlib -march&lt;span style="color:#ff79c6">=&lt;/span>rv32i -mabi&lt;span style="color:#ff79c6">=&lt;/span>ilp32 init.s -o init.o
riscv64-unknown-elf-objcopy -O binary -j .text init.o init.bin
&lt;/code>&lt;/pre>&lt;/div>&lt;p>再对&lt;code>init.bin&lt;/code>进行反编译，我们可以看到：&lt;/p>
&lt;pre>&lt;code>➜ riscv64-unknown-elf-objdump -D -b binary init.bin -mriscv
init.bin: file format binary
Disassembly of section .data:
0000000000000000 &amp;lt;.data&amp;gt;:
0: 00010137 lui sp,0x10
&lt;/code>&lt;/pre>&lt;p>汇编生成的机器码没有任何问题，它只含有一句话。我们用 &lt;code>cat&lt;/code> 将 &lt;code>init.bin&lt;/code> 附到 &lt;code>main.bin&lt;/code> 前面（注意调用顺序）：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">cat init.bin main.bin &amp;gt; final_cat.bin
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到我们生成了 &lt;code>final_cat.bin&lt;/code>。对它进行反编译，我们可以看到：&lt;/p>
&lt;pre>&lt;code>➜ riscv64-unknown-elf-objdump -D -b binary final_cat.bin -mriscv
final_cat.bin: file format binary
Disassembly of section .data:
0000000000000000 &amp;lt;.data&amp;gt;:
0: 00010137 lui sp,0x10
4: fd010113 addi sp,sp,-48 # 0xffd0
8: 02812623 sw s0,44(sp)
c: 03010413 addi s0,sp,48
...
&lt;/code>&lt;/pre>&lt;p>我们的&lt;code>lui sp,0x10&lt;/code>被成功加到了最前面。此时将 &lt;code>final_cat.bin&lt;/code> 烧录进 ROM，可以看到程序&lt;strong>正常运行&lt;/strong>。&lt;/p>
&lt;p>总结一下，用 cat 合并的步骤是：&lt;/p>
&lt;ol>
&lt;li>分别编写 C 语言部分和汇编部分，编译后剪成纯二进制格式&lt;/li>
&lt;li>用 cat 将两个 binary 合并在一起，注意顺序。&lt;/li>
&lt;li>烧录，运行。&lt;/li>
&lt;/ol>
&lt;h3 id="方法2-用-ld-合并">方法2 用 ld 合并&lt;/h3>
&lt;p>直接缝合两个二进制文件在这个例子中没有问题，因为&lt;code>main.bin&lt;/code>里面的地址都是相对地址，在它前面加一个指令并不会导致后面的指令出问题。但是更正规的做法是用 &lt;code>ld&lt;/code> 缝合两个部分：在汇编中，我们导入 C 语言的 &lt;code>main&lt;/code> 函数，在汇编程序中调用它。&lt;/p>
&lt;p>&lt;code>init.s&lt;/code> 改写如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">&lt;span style="color:#50fa7b">.text&lt;/span>
&lt;span style="color:#50fa7b">.globl&lt;/span> main
&lt;span style="color:#50fa7b">lui&lt;/span> x2, &lt;span style="color:#bd93f9">0x00010&lt;/span>
&lt;span style="color:#50fa7b">call&lt;/span> main
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后我们编译这些源文件：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">riscv64-unknown-elf-gcc -c -nostdlib init.s init.o
riscv64-unknown-elf-gcc -c -nostdlib main.c main.o
riscv64-unknown-elf-ld -melf32lriscv -o final.o init.o main.o
riscv64-unknown-elf-objcopy -O binary final.o final_ld
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 ld 的 &lt;code>-melf32lriscv&lt;/code> 参数用于指定架构。&lt;/p>
&lt;p>我们再反编译一下结果，看一下用 ld 生成的和 cat 生成的二进制文件有什么区别：&lt;/p>
&lt;pre>&lt;code>➜ riscv64-unknown-elf-objdump -b binary -D -mriscv final_ld
final_ld: file format binary
Disassembly of section .data:
0000000000000000 &amp;lt;.data&amp;gt;:
0: 00010137 lui sp,0x10
4: 004000ef jal ra,0x8
8: fd010113 addi sp,sp,-48 # 0xffd0
c: 02812623 sw s0,44(sp)
10: 03010413 addi s0,sp,48
...
&lt;/code>&lt;/pre>&lt;p>可以看到，在&lt;code>0x4&lt;/code>的位置多了一条 &lt;code>jal ra,0x8&lt;/code>。这是 &lt;code>ld&lt;/code> 进行链接的结果。&lt;/p>
&lt;p>将程序烧录进 ROM ，运行仿真，可以看到我们的结果被正确计算：&lt;/p>
&lt;p>&lt;img src="final.png" alt="" />&lt;/p>
&lt;p>总结一下，用 ld 连接的步骤是：&lt;/p>
&lt;ol>
&lt;li>编写 C 语言部分，编译成 ELF 文件。&lt;/li>
&lt;li>编写汇编语言部分，它负责初始化栈顶指针。也编译成 ELF 文件。&lt;/li>
&lt;li>用 ld 将两个部分连接到一起。&lt;/li>
&lt;li>连接后用 &lt;code>objcopy&lt;/code> 剪成纯二进制文件。&lt;/li>
&lt;li>烧录，运行。&lt;/li>
&lt;/ol>
&lt;h2 id="使用-makefile-自动构建">使用 Makefile 自动构建&lt;/h2>
&lt;p>无论是方法1还是方法2，编译流程都比较复杂，借用某名星的话：&lt;code>TMD 烦死了&lt;/code>。所以我们可以用 Makefile 完成编译连接剪切一整套流程：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Makefile" data-lang="Makefile">&lt;span style="color:#8be9fd;font-style:italic">CROSS_COMPILE&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>riscv64-unknown-elf-
&lt;span style="color:#8be9fd;font-style:italic">CC&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>CROSS_COMPILE&lt;span style="color:#ff79c6">)&lt;/span>gcc
&lt;span style="color:#8be9fd;font-style:italic">CFLAGS&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>-c -nostdlib -march&lt;span style="color:#ff79c6">=&lt;/span>rv32i -mabi&lt;span style="color:#ff79c6">=&lt;/span>ilp32
&lt;span style="color:#8be9fd;font-style:italic">OBJCOPY&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>CROSS_COMPILE&lt;span style="color:#ff79c6">)&lt;/span>objcopy
&lt;span style="color:#8be9fd;font-style:italic">OBJCOPYFLAGS&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>-O binary -j .text
&lt;span style="color:#8be9fd;font-style:italic">LD&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>CROSS_COMPILE&lt;span style="color:#ff79c6">)&lt;/span>ld
&lt;span style="color:#8be9fd;font-style:italic">LDFLAGS&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>-melf32lriscv
&lt;span style="color:#50fa7b">all&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> main.o init.o
&lt;span style="color:#ff79c6">$(&lt;/span>LD&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">$(&lt;/span>LDFLAGS&lt;span style="color:#ff79c6">)&lt;/span> -o final.o init.o main.o
&lt;span style="color:#ff79c6">$(&lt;/span>OBJCOPY&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">$(&lt;/span>OBJCOPYFLAGS&lt;span style="color:#ff79c6">)&lt;/span> final.o final
&lt;span style="color:#50fa7b">main.o&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> main.c
&lt;span style="color:#ff79c6">$(&lt;/span>CC&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">$(&lt;/span>CFLAGS&lt;span style="color:#ff79c6">)&lt;/span> main.c -o main.o
&lt;span style="color:#50fa7b">init.o&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> init.s
&lt;span style="color:#ff79c6">$(&lt;/span>CC&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">$(&lt;/span>CFLAGS&lt;span style="color:#ff79c6">)&lt;/span> init.s -o init.o
&lt;span style="color:#50fa7b">clean&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
rm -f *.o
rm -f *.bin
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="faq">FAQ&lt;/h1>
&lt;h2 id="newlib-和-linux-的工具链有什么区别">Newlib 和 Linux 的工具链有什么区别&lt;/h2>
&lt;p>Newlib 是不带 Glibc 的，也不支持动态链接。&lt;/p>
&lt;p>这两个工具链生成的 ELF 文件略有区别。下面是 Linux 工具链生成的 ELF文件，我们对其 objdump：&lt;/p>
&lt;pre>&lt;code>➜ riscv64-linux-gnu-objdump -x fibl
fibl: file format elf32-littleriscv
fibl
architecture: riscv:rv32, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x000100b8
Program Header:
LOAD off 0x00000000 vaddr 0x00010000 paddr 0x00010000 align 2**12
filesz 0x000001a0 memsz 0x000001a0 flags r-x
NOTE off 0x00000094 vaddr 0x00010094 paddr 0x00010094 align 2**2
filesz 0x00000024 memsz 0x00000024 flags r--
STACK off 0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4
filesz 0x00000000 memsz 0x00000000 flags rw-
Sections:
Idx Name Size VMA LMA File off Algn
0 .note.gnu.build-id 00000024 00010094 00010094 00000094 2**2
CONTENTS, ALLOC, LOAD, READONLY, DATA
1 .text 000000e8 000100b8 000100b8 000000b8 2**2
CONTENTS, ALLOC, LOAD, READONLY, CODE
2 .comment 00000012 00000000 00000000 000001a0 2**0
CONTENTS, READONLY
SYMBOL TABLE:
no symbols
&lt;/code>&lt;/pre>&lt;p>下面是 Newlib 工具链生成的 ELF 文件的 objdump 结果：&lt;/p>
&lt;pre>&lt;code>➜ riscv64-unknown-elf-objdump -x fibu
fibu: file format elf32-littleriscv
fibu
architecture: riscv:rv32, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00010054
Program Header:
LOAD off 0x00000000 vaddr 0x00010000 paddr 0x00010000 align 2**12
filesz 0x0000013c memsz 0x0000013c flags r-x
Sections:
Idx Name Size VMA LMA File off Algn
0 .text 000000e8 00010054 00010054 00000054 2**2
CONTENTS, ALLOC, LOAD, READONLY, CODE
1 .comment 00000022 00000000 00000000 0000013c 2**0
CONTENTS, READONLY
2 .riscv.attributes 0000001c 00000000 00000000 0000015e 2**0
CONTENTS, READONLY
SYMBOL TABLE:
no symbols
&lt;/code>&lt;/pre>&lt;p>可以看到，两者的差别在于 &lt;code>.note.gnu.build-id&lt;/code> 和 &lt;code>.riscv.attributes&lt;/code> 这两个部分。不过这些都是无关的注释信息。我们再用 &lt;code>objcopy&lt;/code> 把 ELF 文件处理一下，只保留 &lt;code>.text&lt;/code> 部分。可以看到，生成的纯二进制文件是一样的。&lt;/p>
&lt;p>因为我们只需要&lt;code>.text&lt;/code>部分的机器码，并且我们的程序也不涉及动态链接的问题。所以在这个代码上，用这两个工具链并无实质上的区别。不过我仍然推荐 &lt;code>Newlib&lt;/code> 版本的工具链，因为它只有静态编译，更适合嵌入式编程这个场景。&lt;/p>
&lt;h2 id="32位的处理器为什么要用-riscv64-的工具链">32位的处理器为什么要用 riscv64 的工具链&lt;/h2>
&lt;p>这个问题我也注意到了。在一些老的文章，例如这篇&lt;a href="https://five-embeddev.com/toolchain/2019/06/26/gcc-targets/">RISC-V Compile Targets, GCC&lt;/a>，里面会提到&lt;code>riscv32-&lt;/code>开头的工具链。但实际上现在的 &lt;code>riscv64&lt;/code> 工具链已经包含了 32 位支持：&lt;/p>
&lt;blockquote>
&lt;p>Yeah, that confused me too. The riscv toolchain is a little funny in that way. Upstream recommends you just build the riscv64-unknown-elf-gcc and then compile with -march=rv32i -mabi=ilp32 (or whatever suits your platform).&lt;/p>
&lt;/blockquote>
&lt;p>来源：&lt;a href="https://aur.archlinux.org/packages/riscv64-unknown-elf-gcc/">AUR 上的讨论&lt;/a>。&lt;/p>
&lt;h2 id="直接用-cat-合并不用担心重定位的问题吗">直接用 cat 合并，不用担心重定位的问题吗&lt;/h2>
&lt;p>不用。因为所有的跳转都基于相对地址。&lt;/p>
&lt;p>反编译可以发现，cat 缝合的二进制，在 0x2c 处有一句&lt;code>j 0x5c&lt;/code>。同样的代码出现在 ld 版本的 0x30 处，并且变成了 &lt;code>j 0x60&lt;/code>。但它们的机器码是一样的，都是&lt;code>0x0300006F&lt;/code>。所以用 cat 在 &lt;code>main.bin&lt;/code> 前面加一万句话都没事。&lt;/p>
&lt;p>我用两种方法都编译了一次，发现 &lt;code>ld&lt;/code> 生成和 &lt;code>cat&lt;/code> 直接缝合的两个二进制程序，实际上只差了一句 &lt;code>jal ra,0x8&lt;/code>。这句是调用约定，不过我们的 &lt;code>main&lt;/code> 函数并不需要返回，所以无所谓啦。&lt;/p>
&lt;h2 id="内存大小的问题">内存大小的问题&lt;/h2>
&lt;p>我们在这里规定的栈顶指针初始值是&lt;code>0x10000&lt;/code>。请根据你的实际内存大小进行修改。&lt;/p>
&lt;p>如果你有兴趣进行综合，那么一定要注意，有些板子的内存是不够的，例如 EGO-1。但 Minisys 好像是可以的。&lt;/p>
&lt;h1 id="最后">最后&lt;/h1>
&lt;p>在写文章的过程中，发现自己之前是误打误撞做出来的，能跑起来纯属瞎猫碰上死耗子。这个文章写了一整天，人都快没了，已经被机器码恶心死了（bushi&lt;/p>
&lt;p>在编写过程中参考了以下资料：&lt;/p>
&lt;p>&lt;a href="http://crva.ict.ac.cn/documents/RISC-V-Reader-Chinese-v2p1.pdf.11.3">RISC-V 中文手册&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.cs.cornell.edu/courses/cs3410/2019sp/riscv/interpreter/">RISC-V Online Interpreter&lt;/a> （十分推荐，可以在线运行 RISC-V 汇编指令）&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/questions/47028724/newlib-embedded-vs-desktop">StackOverflow - Newlib: embedded vs desktop&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://aur.archlinux.org/packages/riscv64-unknown-elf-gcc/">AUR (en) - riscv64-unknown-elf-gcc&lt;/a>&lt;/p>
&lt;p>另外感谢王老师提供的 CPU 讲解课程及实验器械，以及孟老师对一些问题的解答。&lt;/p>
- https://risehere.net/posts/running-c-program-on-bare-machine/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>为什么有些汉字在日语中会读成两拍</title><link>https://risehere.net/posts/checked-tone-in-japanese/</link><pubDate>Sat, 07 Nov 2020 10:45:28 +0800</pubDate><guid>https://risehere.net/posts/checked-tone-in-japanese/</guid><description>左手的世界 https://risehere.net/posts/checked-tone-in-japanese/ -&lt;h1 id="前言">前言&lt;/h1>
&lt;p>写这篇文章的动机，还要从8月说起。那天我在网上冲浪时无意间发现了“沉默”一词的最初写法应为“沈默”。我说，这一点可以在&lt;a href="https://zh.wiktionary.org/zh-hant/%E6%B2%88%E9%BB%98">日语、朝鲜语、越南语中“沈默”一词的汉字写法&lt;/a>上得到印证，并附上了一张维基字典的截图。&lt;/p>
&lt;p>此时一位师兄突然指出，日语汉字“黙”（もく，mo ku）&lt;strong>读成两拍&lt;/strong>的原因是，末尾的“く”是在&lt;strong>模拟古汉语中的“入声”&lt;/strong>。经过一番资料查找，我对日语中的“入声”终于有了点小小的认识，今分享于此。&lt;/p>
&lt;p>这篇文章不是一个严肃的研究文章，只是我对东亚文化圈中一些有趣现象的记录，大家看个乐呵就行。本文将会简单介绍日语的一些特点，以及中古汉语留下的蛛丝马迹&amp;ndash;“入声”。&lt;/p>
&lt;blockquote>
&lt;p>声明：本人并非专业的语言学研究人员，文章中如有错误，欢迎指正！&lt;/p>
&lt;/blockquote>
&lt;p>欲读懂本文：&lt;/p>
&lt;ul>
&lt;li>你需要了解日本的五十音图。不过所有的假名我都附上了罗马音，所以大概了解五十音图就可以。&lt;/li>
&lt;li>你需要对入声有一点了解，可参见&lt;a href="https://risehere.net/2019/10/27/checked-tone-in-cantonese/#%e5%85%a5%e5%a3%b0">粤语的声调与入声 - 入声&lt;/a>一节。&lt;/li>
&lt;li>另外，我用粤语拼音模拟了一下中古汉语的拼音。对于没有学过粤语的读者，可以把粤拼当作英文来读。&lt;/li>
&lt;/ul>
&lt;p>其它知识我会在文中予以补充，请大家放心食用。&lt;/p>
&lt;h1 id="正文">正文&lt;/h1>
&lt;h2 id="汉字传入日本">汉字传入日本&lt;/h2>
&lt;p>日本刚开始是没有文字的，但出于文化传播的需要，日本需要借来汉字来表达他们的语言。于是，在几百年的中日交流中，既借来了汉字用于表音（表达读音），又借来了汉字用于表意（表达意思）。这里引用《写给大家的日语史》中的一个例子：汉字“山”。&lt;/p>
&lt;ul>
&lt;li>将山的读音借来了，读作サン(sa n)。&lt;/li>
&lt;li>又让山表意，对应日语中固有（即当地人自己发明）的やま(ya ma)。即，山在这种情况下读音为やま。&lt;/li>
&lt;/ul>
&lt;p>所以，一个汉字通常有两类读法：前者被称为“音读”，后者被称为“训读”。本文的主角“入声”主要存在于&lt;strong>音读&lt;/strong>中。&lt;/p>
&lt;p>援引自维基百科，音读按照传入日本的时间，分为以下几种：&lt;/p>
&lt;ul>
&lt;li>古音：早于吴音传入日本的汉字音。源于中国上古音。&lt;/li>
&lt;li>吴音：早在公元5世纪、6世纪辗转而入的字音。&lt;/li>
&lt;li>汉音：于公元7世纪左右，日本始派出遣唐使自大唐所习得之字音。对当代日语影响最为深远。&lt;/li>
&lt;li>唐音：指宋元以后才传入日本的汉字读音，以南方口音为基准。&lt;/li>
&lt;/ul>
&lt;p>而这几次传入，中国基本都处在&lt;strong>中古汉语&lt;/strong>时期。这个时期的汉语是带有&lt;strong>入声&lt;/strong>的。而大多数入声字，在日语中都会读成两拍。下面我将说明这一现象的来龙去脉。&lt;/p>
&lt;h2 id="为什么入声读两拍">为什么入声读两拍&lt;/h2>
&lt;p>日语的音节多数为&lt;strong>开音节&lt;/strong>，意思就是读音是“辅音+元音”的结构（拨音ん和促音っ则是例外）。&lt;/p>
&lt;p>举个直观的例子，球员贝克汉姆，可以翻译成以下读音：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>汉语普通话&lt;/th>
&lt;th>粤语&lt;/th>
&lt;th>日语&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>写作&lt;/td>
&lt;td>贝克汉姆&lt;/td>
&lt;td>碧咸&lt;/td>
&lt;td>ベッカム&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>读作&lt;/td>
&lt;td>bei ke han mu&lt;/td>
&lt;td>bik ham&lt;/td>
&lt;td>Be kka mu&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>可以看到，汉语普通话和日语同为&lt;strong>开音节&lt;/strong>占优势语言，在翻译形如 ham 的音时，总要把 ha 与 m 拆开，后加一个&lt;strong>多余的元音&lt;/strong>，构成开音节。同理，日本将中古汉语带入日语时，在入声字的结尾再加入一个元音，构成一个开音节。&lt;/p>
&lt;p>这也是汉字中的一个入声字，对应到日语中有两拍的原因。&lt;/p>
&lt;p>那么这种一字对应两拍的关系，是否有固定的规律呢？答案是有的。&lt;/p>
&lt;h2 id="入声单字的一般规律">入声单字的一般规律&lt;/h2>
&lt;p>在中古汉语时期，入声主要有三种韵尾：-p，-t，-k。我们可以发现，当下文提到的入声字单独出现时，它们的音读总是&lt;strong>两拍&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>由于笔者水平有限，此处用粤语模拟中古汉语。&lt;/p>
&lt;/blockquote>
&lt;h3 id="t类">t类&lt;/h3>
&lt;p>中古汉语中的t类韵尾大多变为日语中的ち或つ。&lt;/p>
&lt;p>举例：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>粤语拼音&lt;/th>
&lt;th>假名&lt;/th>
&lt;th>罗马音&lt;/th>
&lt;th>变化规律&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>一&lt;/td>
&lt;td>yat&lt;/td>
&lt;td>いち&lt;/td>
&lt;td>i chi&lt;/td>
&lt;td>t - chi&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>節&lt;/td>
&lt;td>zit&lt;/td>
&lt;td>せつ&lt;/td>
&lt;td>se tsu&lt;/td>
&lt;td>t - tsu&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>用文字来描述，就是一(yat，或写作jat)，末尾含有入声，日语里会在末尾加个ち（chi），变成いち（i chi）。&lt;/p>
&lt;h3 id="k类">k类&lt;/h3>
&lt;p>k类韵尾大多变为く或き。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>粤语拼音&lt;/th>
&lt;th>假名&lt;/th>
&lt;th>罗马音&lt;/th>
&lt;th>变化规律&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>学&lt;/td>
&lt;td>hok&lt;/td>
&lt;td>がく&lt;/td>
&lt;td>ga ku&lt;/td>
&lt;td>k - ku&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>益&lt;/td>
&lt;td>yik&lt;/td>
&lt;td>えき&lt;/td>
&lt;td>e ki&lt;/td>
&lt;td>k - ki&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>注：益的粤拼也可写作jik。&lt;/p>
&lt;h3 id="p类">p类&lt;/h3>
&lt;p>p类入声字的结尾大多为う。例如：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>粤语拼音&lt;/th>
&lt;th>假名&lt;/th>
&lt;th>罗马音&lt;/th>
&lt;th>变化规律&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>十&lt;/td>
&lt;td>sap&lt;/td>
&lt;td>じゅう&lt;/td>
&lt;td>zyuu&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>急&lt;/td>
&lt;td>gap&lt;/td>
&lt;td>きゅう&lt;/td>
&lt;td>kyuu&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>你可能会感到很奇怪，为什么p类入声的变化和前面两个都不一样。前两个都是简单地加一个元音构成开音节，而这个ゅう看起来一点都不像p变化过来的。&lt;/p>
&lt;p>实际上，最早p类入声字对应的是ふ。最早“急”的读音是“きふ”（按当时的读音写作罗马音应为 ki pu）。后面经历了“ハ行転呼”， 所有的ipu结尾的读音都经历了这个变化：&lt;/p>
&lt;blockquote>
&lt;p>ipu → ifu → iu → yuu&lt;/p>
&lt;/blockquote>
&lt;p>具体可以参见&lt;a href="https://zh.wikipedia.org/zh-cn/%E3%83%8F%E8%A1%8C%E8%BD%89%E5%91%BC">维基百科&lt;/a>，以及&lt;a href="https://www.zhihu.com/question/264132123">这篇知乎问题&lt;/a>。&lt;/p>
&lt;h2 id="入声字组词时">入声字组词时&lt;/h2>
&lt;p>如果入声字的后面再加一个字，可能会有两种情况：&lt;/p>
&lt;ul>
&lt;li>入声字的读音不变。&lt;/li>
&lt;li>入声字变为促音。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>促音，写作っ。在日语中要在促音出现的地方停顿一下。如きぷ（ki pu）占两拍，加入促音的きっぷ（kippu）占三拍，中间暂停一拍，读起来像是ki（空）pu。罗马音里用双写来表示。&lt;/p>
&lt;/blockquote>
&lt;p>这两种情况的具体解释写在《基于优选论对日语汉字词中促音化现象的分析》论文中（完整来源见结尾）。但在此处我只作&lt;strong>最简单的归纳&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>如果这个入声字后面的字的辅音是&lt;strong>冲突&lt;/strong>的，例如：学（がく，gaku）校（こう，kou）一词中，学的韵尾k与校的起始部分k是相同的，此处应该用促音，&lt;strong>省略&lt;/strong>掉“学”的&lt;strong>韵尾&lt;/strong>变为&lt;strong>促声&lt;/strong>。がく、こう（gaku kou）变为がっこう（ga kko）。&lt;/li>
&lt;li>如果不冲突，例如“学派”，がく和は，则可以直接结合，不需要变为促音。&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>第一个字&lt;/th>
&lt;th>第二个字&lt;/th>
&lt;th>假名写作&lt;/th>
&lt;th>罗马音&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>学（がく，gaku）&lt;/td>
&lt;td>校（こう，kou）&lt;/td>
&lt;td>がっこう&lt;/td>
&lt;td>ga kko&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>学（がく，gaku）&lt;/td>
&lt;td>派（は，ha）&lt;/td>
&lt;td>がくは&lt;/td>
&lt;td>ga ku ha&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>值得注意的是，虽然p尾的入声字在日语中的结尾早已由ふ变为う，但在组词时它仍被看作ふ结尾。例如：十分 - じっぷん (zi ppun)。&lt;/p>
&lt;h1 id="后记">后记&lt;/h1>
&lt;p>写这篇文章花费了不少精力。同时，我也感到了语言的博大精深。这篇文章也只是一个浅谈，更深层的规律则要参考专业人士的论文。&lt;/p>
&lt;p>另外，不得不肯定宗教在文化传播方面的重要作用。毕竟这方面最早的研究，叫作&lt;strong>悉昙学&lt;/strong>。&lt;/p>
&lt;p>日语吸收了汉字，但又没有全盘接受。他们吸收得恰到好处&amp;ndash;既保留了汉字的特征，又服从了日语的音韵特点。最后，我想以 BYVoid 大佬的一段话作结尾（源自&lt;a href="https://byvoid.com/zht/blog/4-years-at-google-5/">这里&lt;/a>）。&lt;/p>
&lt;blockquote>
&lt;p>日本是一個熟悉而又陌生的國度。熟悉之處在於日本深受中國古典文化的影響，近代至今則反過來向中國輸出了大量文化。陌生之處在於，相比漢字文化圈的朝鮮半島和越南，日本對中國文化的吸收總是有分寸。這種感覺日本文化中隱隱約約有大唐遺風，但又絕對不是另一個「小中華」。&lt;/p>
&lt;/blockquote>
&lt;h1 id="参考">参考&lt;/h1>
&lt;ol>
&lt;li>《写给大家的日语史》（日语版「日本語の歷史」） 作者：山口仲美&lt;/li>
&lt;li>《日语概说》 作者：皮细庚&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E9%9F%B3%E8%AE%80">音读 - 维基百科&lt;/a>&lt;/li>
&lt;li>石晨.从中古汉语入声字看日语汉字词中的促音[J].日语学习与研究,2016(01):72-78.&lt;/li>
&lt;li>薛华民.基于优选论对日语汉字词中促音化现象的分析[J].教育现代化,2018,5(31):153-158.&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/264132123">在古汉语里，「急」字为入声，可为何在日语里的音读却为「きゅう」？&lt;/a>&lt;/li>
&lt;/ol>
- https://risehere.net/posts/checked-tone-in-japanese/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>古墓丽影考古记</title><link>https://risehere.net/posts/tomb-raider/</link><pubDate>Tue, 11 Aug 2020 08:42:26 +0800</pubDate><guid>https://risehere.net/posts/tomb-raider/</guid><description>左手的世界 https://risehere.net/posts/tomb-raider/ -&lt;h1 id="前言">前言&lt;/h1>
&lt;p>近几日网络不太好，玩 CSGO 都能卡成 &lt;code>Counter Strike: Microsoft PowerPoint&lt;/code>。于是我打算下载个单机游戏，正好前几天在 Steam 里白嫖到了 &lt;code>Tomb Raider&lt;/code>。（等等党の勝利）&lt;/p>
&lt;p>这个游戏在 Steam 里就叫 &lt;code>Tomb Raider&lt;/code> ，我差点以为是 1996 年的那个第一代作品。后来看了一下发行时间，推测出应该是 9 代作品。那么 7 年前的游戏会不会很老套呢？&lt;/p>
&lt;h1 id="正文">正文&lt;/h1>
&lt;h2 id="中规中矩">中规中矩&lt;/h2>
&lt;p>古墓丽影讲的故事中规中矩。换句话说，是一个很老套的西方个人英雄主义故事。游戏难度也不是特别大。&lt;/p>
&lt;ul>
&lt;li>劳拉带有主角光环，能在危楼临立之中反复横跳，如履平地，并且在经历了&lt;code>狂风暴雨&lt;/code>、&lt;code>山崩地陷&lt;/code>、&lt;code>千军万马&lt;/code>、&lt;code>兵临城下&lt;/code>、&lt;code>熊熊大火&lt;/code>、&lt;code>高山蹦极&lt;/code>等极限运动之后依旧安然无恙。&lt;/li>
&lt;li>主角没有血条，只要没有连续伤害就能活（作死跳崖不算）。所以被敌人打得快残的时候，只要苟一会就能原地满血。&lt;/li>
&lt;li>劳拉身负重伤还能活蹦乱跳，伤口浸在污水里仍然大丈夫，丝毫不惧破伤风。&lt;/li>
&lt;li>而有些地方的敌人会选择性失明、失聪。甚至劳拉在武士们头上过独木桥，在墙边上爬，也没有被发现。不过也似乎解释得通：这些日本武士已经活了上千年了，眼神不好使也正常（雾）。&lt;/li>
&lt;li>就算死了，也能从存档点复活。并且随时随地都能存档。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="20200810103931_1.jpg" alt="" />&lt;/p>
&lt;p>难道这个游戏真的是一款老掉牙的过气游戏吗？&lt;/p>
&lt;h2 id="制作精良">制作精良&lt;/h2>
&lt;p>当然不是。它的制作之精良甚至令人叹为观止。现在也是。&lt;/p>
&lt;h3 id="林深见鹿-飞泉碧峰">林深见鹿 飞泉碧峰&lt;/h3>
&lt;p>在游戏里的第二天早上，天晴了，劳拉在营地醒来，破败的荒岛深林居然也开始浮现出勃勃生机。发了一把弓，需要用它射动物。虽然说这事有点残忍，但主角作为幸存者，要恰饭的嘛。&lt;/p>
&lt;p>这个游戏的射击手感非常棒，在完成第一个任务的时候居然会有一种“在玩休闲打猎游戏”的错觉。小溪潺潺，鹿鸣呦呦，&lt;del>完全不是一个冒险游戏该有的样子。&lt;/del> （啊说到这个，通关之后我还去林子里继续打了一会猎来着，真的上瘾。）&lt;/p>
&lt;h3 id="运镜巧妙-画幅宏伟">运镜巧妙 画幅宏伟&lt;/h3>
&lt;p>除此之外，游戏对于构图和运镜也十分考究。有一幕是，劳拉需要爬无线电塔，向紧急电台发送求救信号。这时，镜头渐渐拉远，天空中微微飘着雪，苍茫的大地在屏幕里无限延伸，与渺小的劳拉形成了鲜明的对比。突然就有一种“寄蜉蝣于天地，渺沧海之一粟”的空虚感。&lt;/p>
&lt;p>是的，在大自然面前，人就是蝼蚁一般的存在。&lt;del>随后过来救援的直升机就被雷电击中了。&lt;/del>&lt;/p>
&lt;p>&lt;img src="20200809203835_1.jpg" alt="" />&lt;/p>
&lt;p>下图打败最终 BOSS 的视角。圣洁的光，照在了大地上（雾）&lt;/p>
&lt;p>&lt;img src="20200810173422_1.jpg" alt="" />&lt;/p>
&lt;p>还有另外几处攀爬地点，在经过这些地点时，镜头也会自动拉到一个合适的角度，不会使人产生眩晕感。并且这种手法和电影运镜很相似，让人有一种在看大片的感觉，体验极佳。&lt;/p>
&lt;h3 id="宝物瑰丽-建筑精美">宝物瑰丽 建筑精美&lt;/h3>
&lt;p>失落的日本邪马台（虚构）古文明究竟是什么样子？我们不曾得知。但游戏制作方从各个角度呈现出了古老帝国曾经的辉煌。&lt;/p>
&lt;p>邪马台的宫殿历经风霜雨雪，仍旧矗立在这个荒岛上，宏伟而壮观。&lt;/p>
&lt;p>&lt;img src="20200809214307_1.jpg" alt="" />&lt;/p>
&lt;p>这里也有辉煌的大型古代墓穴，在地下甚至有高耸的楼阁，和一幅幅精美而巨大的壁画。&lt;/p>
&lt;p>&lt;img src="20200811175317_1.jpg" alt="" />&lt;/p>
&lt;p>在这里，不仅有日本的古物，他们还发现了来自中国和泰国等地的文物。说明这个古老的帝国文明和东亚各国，乃至东南亚都有过密切交流。&lt;/p>
&lt;p>仔细观察就会发现，岛上也有二战时期的一些遗留：地上的很多遗体还披着日本二战时候的军装，很多指示牌也是二战时期的，还有一个分支墓位于二战废弃实验室。从这些细节我们可以窥探出，这个岛曾经是一个重要的军事基地。但遗憾的是，游戏未能在此展开。&lt;/p>
&lt;p>（有一说一，那个二战废弃实验室的分支墓居然是古风，给人一种风马牛不相及的感觉。）&lt;/p>
&lt;h3 id="开放世界-永不止步">开放世界 永不止步&lt;/h3>
&lt;p>这个游戏是开放世界游戏。在完成主线结局后，你可以继续在岛上完成剩余部分的探索。不过这个在现在已经不是什么亮点了，在此游戏发售之前就有很多开放世界游戏了。&lt;/p>
&lt;p>刚开始我是打算先粗略通关一次，分支留着下次再仔细打。没想到在游戏的最后，劳拉说：我可不打算回家，我还要继续探索。原来在结局后还能继续探索！令我有点失望的是，分支墓规模很小，开到最后也只有一个宝箱。&lt;/p>
&lt;p>&lt;img src="20200811180704_1.jpg" alt="" />&lt;/p>
&lt;p>另外，这个游戏还支持联机，而且有多种模式，看来制作组野心不小。它作为 FPS 手感还真说得过去，不过它一直不温不火，我认为是有些遗憾的。&lt;/p>
&lt;h3 id="主角好看-真的好看">主角好看 真的好看&lt;/h3>
&lt;p>主角是真的好看，这我就不必多说了，你们自己下载一个就知道了，2333。（不会编了）&lt;/p>
&lt;p>&lt;img src="20200810173600_1.jpg" alt="" />&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;h2 id="对游戏的结语">对游戏的结语&lt;/h2>
&lt;p>任何事物不可能做到完美，它也有一些缺点。文章刚开始的时候说的难度低，虽然有很多人吐槽，但也算是可以理解的：因为如果游戏过难，就不容易突出它的故事性了。除此之外，它所讲的故事有些过于牵强，主角居然为了救一个人而使那么多人牺牲。&lt;/p>
&lt;p>不过，总体来看，还是瑕不掩瑜的，可以看出制作组在很多地方都十分用心。这款游戏在现在（2020年）来看，不算落伍。时至今日，它仍是一部可玩性很高的大作。&lt;/p>
&lt;p>如果有人问我这款游戏是否值得入手，我一定会说，值得。&lt;/p>
&lt;p>&lt;img src="20200810150442_1.jpg" alt="" />&lt;/p>
&lt;p>（就算为了看看劳拉，也不错的！）&lt;/p>
&lt;h2 id="关于本篇">关于本篇&lt;/h2>
&lt;p>写文章呢，是希望以这种方式纪念一下通关的游戏。&lt;/p>
&lt;p>这篇文章全都是五笔打出的。在练习了半年五笔后，我已经基本习惯了五笔的节奏，再也不想在电脑上用拼音输入法选字了。&lt;/p>
&lt;p>同时，写这篇文章花了我一天多时间，加班加点赶出来。因为我害怕时间长不写，就像前面几篇咕了的稿子一样，放久了就再也不想写了。（我现在积压了四篇，你敢信&amp;hellip;）&lt;/p>
&lt;p>本文权当抛砖引玉。大家如果有什么不同的见解，请在下方发表。欢迎交流。&lt;/p>
- https://risehere.net/posts/tomb-raider/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>粤语的声调及入声</title><link>https://risehere.net/2019/10/27/checked-tone-in-cantonese/</link><pubDate>Sat, 04 Jul 2020 00:00:00 +0000</pubDate><guid>https://risehere.net/2019/10/27/checked-tone-in-cantonese/</guid><description>左手的世界 https://risehere.net/2019/10/27/checked-tone-in-cantonese/ -&lt;blockquote>
&lt;p>本文原发于2019.10.27。今日梳理了一下文章思路，删除了一些冗余的内容，并调整了一下文章的结构。&lt;/p>
&lt;/blockquote>
&lt;h1 id="前言">前言&lt;/h1>
&lt;p>汉语读起来十分动听， 而它正是以其抑扬顿挫之语调而著名。而粤语(广州话)中很好保留了中古汉语中的一些特征，例如声调和韵尾。&lt;/p>
&lt;p>本文将要介绍粤语的声调和韵尾。由于本人并非专业研究人员。若有错误欢迎指正！&lt;/p>
&lt;blockquote>
&lt;p>注：下文所指粤语，均为广州话为代表的粤语。&lt;/p>
&lt;/blockquote>
&lt;h1 id="声调">声调&lt;/h1>
&lt;h2 id="五度标记法">五度标记法&lt;/h2>
&lt;p>为了更好地给大家介绍粤语声调，这里先引入一种记录现代汉语声调的最广泛的方法：五度标记法。五度标记法在汉语方言相关研究中大量使用。 (由&lt;a href="https://zh.wikipedia%E3%80%82org/wiki/%E8%B5%B5%E5%85%83%E4%BB%BB">赵元任先生&lt;/a>发明，他被称为汉语言学之父)&lt;/p>
&lt;p>五度标记法它标记了一个音韵的起始，中间过程(有时省略)，和结尾的音调高低。
下面我将以现代汉语普通话为例， 跟大家介绍一下五度标记法。&lt;/p>
&lt;p>现代汉语拼音方案中用一声，二声，三声，四声表示普通话中的四个音调。以这四个声调为例，我放出一张用&lt;em>五度标记法&lt;/em>标记的四个声调的图，大家先体会一下。&lt;/p>
&lt;p>&lt;img src="pinyin-tone-chart.png" alt="" />&lt;/p>
&lt;p>曲线很直观，声调越高，曲线中对应的那一点越高。而某一位置所对应的数值越高，则代表该位置的数字表示的声调越高。我们可以从图中读出，普通话中：&lt;/p>
&lt;ul>
&lt;li>一声的调值为55&lt;/li>
&lt;li>二声的调值为35&lt;/li>
&lt;li>三声的调值为214&lt;/li>
&lt;li>四声的调值为51&lt;/li>
&lt;/ul>
&lt;p>大家可以尝试用普通话大声朗读这四个字来体会一下。&lt;/p>
&lt;p>番（fan 一声）[55]，茄（qie 二声）[35]，炒（chao 三声）[214]，蛋（dan 四声）[51]。&lt;/p>
&lt;p>(感谢维基百科提供的好例子)&lt;/p>
&lt;p>我们可以看出，五度标记法的数字是有表面含义的，它们每个都代表&lt;strong>调的相对高低&lt;/strong>。而现代汉语拼音方案的数字是无表面意义的，只是&lt;strong>四种调型的序号&lt;/strong>而已。&lt;/p>
&lt;h2 id="粤语的九声六调">粤语的九声六调&lt;/h2>
&lt;p>目前最广泛的粤语拼音方案是粤拼，也就是香港语言学学会的粤语拼音方案。本文采用粤拼来标注粤语的声调。&lt;/p>
&lt;p>援引自「&lt;a href="http://input.foruto.com/ccc/jyt/005.htm">中文字元资料页&lt;/a>」的内容：&lt;/p>
&lt;blockquote>
&lt;p>粤音则由四声，发展成九种声调，分别为：「阴平」、「阴上」、「阴去」，「阳平」、「阳上」、「阳去」，「阴入」、「中入」和「阳入」。其中「阴平、阴上、阴去、阴入、中入」是阴声系，「阳平、阳上、阳去、阳入」是阳声系。阴声系的调值较高，阳声系的调值较低。&lt;/p>
&lt;/blockquote>
&lt;p>这些声调分别对应粤拼方案的1-9。不过这段话可能过于抽象。为了让大家更好理解，我们来用刚刚学的五度标记法来标识一下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>音调&lt;/th>
&lt;th>阴平&lt;/th>
&lt;th>阴上&lt;/th>
&lt;th>阴去&lt;/th>
&lt;th>阳平&lt;/th>
&lt;th>阳上&lt;/th>
&lt;th>阳去&lt;/th>
&lt;th>阴入&lt;/th>
&lt;th>中入&lt;/th>
&lt;th>阳入&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>粤拼&lt;/td>
&lt;td>1&lt;/td>
&lt;td>2&lt;/td>
&lt;td>3&lt;/td>
&lt;td>4&lt;/td>
&lt;td>5&lt;/td>
&lt;td>6&lt;/td>
&lt;td>7&lt;/td>
&lt;td>8&lt;/td>
&lt;td>9&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>五度&lt;/td>
&lt;td>55/53&lt;/td>
&lt;td>35&lt;/td>
&lt;td>33&lt;/td>
&lt;td>11/21&lt;/td>
&lt;td>13&lt;/td>
&lt;td>22&lt;/td>
&lt;td>5(5)&lt;/td>
&lt;td>3(3)&lt;/td>
&lt;td>2(2)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>我们可以看到，粤拼的数字，与现代汉语拼音方案都&lt;strong>仅仅代表某一个调型&lt;/strong>，并不代表本身声调的高低，数值本身是无意义的。&lt;/p>
&lt;p>下面附上更加直观的曲线法。(图片来自&lt;a href="http://www.cantonese.asia/portal.php?mod=view&amp;amp;aid=229">粤语协会&lt;/a>)&lt;/p>
&lt;p>&lt;img src="tone.jpg" alt="" />&lt;/p>
&lt;blockquote>
&lt;p>图中省略了7 8 9三个声调，因为它们的音高与1 3 6的起点是相同的。人们说粤语有「九声六调」（九个声调，六种音高）。至于语音学学者，则大多把「声调」直接定义作音高，不计算其顿错性，就会直接说粤语有「六个声调」。两种说法的分别，只是对「声调」定义不同而已。&lt;/p>
&lt;/blockquote>
&lt;p>有一个简单的方法，你需要找一个会广州话的人，分别读一下「三 九 四 零 五 二 七 八 六」。
这九个数字正好分别对应粤拼的1 2 3 4 5 6 7 8 9声。&lt;/p>
&lt;p>如果读者在此对于区分六个音调仍然存疑，可进入这个网站:&lt;a href="http://www.iso10646hk.net/jp/learning/course_03.jsp">香港语言学学会粤语拼音方案&lt;/a>进行音频试听。&lt;/p>
&lt;p>个人认为，对于非粤语母语者，学习粤语最准确的方法是先学习这一拼音方案。（不过多听多看是根本）&lt;/p>
&lt;h1 id="入声">入声&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ol>
&lt;li>入声早已消失在现代普通话(或更泛化地说，北方方言)中。但是在一些方言，例如粤语，客家话，闽南语中得以保留。&lt;/li>
&lt;li>与入声相对的是舒声。（所以普通话里面全都是舒声。）&lt;/li>
&lt;li>入声又被称为喉塞音。这种叫法很形象，可能会加快理解的过程。&lt;/li>
&lt;li>入声字的韵尾以塞音快速结束，大部分入声字听起来就像气流突然被阻断。&lt;/li>
&lt;li>然而古代汉语却有入声，时人作赋之时，有些便以入声作为韵尾。(有些诗用方言才能更好地表现出它的艺术特色。下文会举出一些例子。)&lt;/li>
&lt;/ol>
&lt;h2 id="粤语的入声">粤语的入声&lt;/h2>
&lt;p>在粤语中，入声是&lt;code>无声除阻音&lt;/code>。就是说，念到入声的时候，需要有气流的阻断这一过程，但是实际上&lt;strong>不发出声音&lt;/strong>。&lt;/p>
&lt;p>粤语中有三个入声韵尾: &lt;code>-p&lt;/code> &lt;code>-t&lt;/code> &lt;code>-k&lt;/code>。&lt;/p>
&lt;p>最早我无法区分这三个入声的区别。但在读「入」和「日」字的时候，又感觉到这两个字不太一样。&lt;/p>
&lt;ul>
&lt;li>入的粤拼是: jap6&lt;/li>
&lt;li>日的粤拼是: jat6&lt;/li>
&lt;/ul>
&lt;p>同样的区别可以体现在「八」和「百」这两个字上面。&lt;/p>
&lt;ul>
&lt;li>八: baat3&lt;/li>
&lt;li>百: baak3&lt;/li>
&lt;/ul>
&lt;p>大家可以尝试抓一个本地人，听听他们在这些字的末尾是怎么收拢嘴巴的。抓不到的话也可以在这个网站上试听：&lt;a href="http://www.iso10646hk.net/jp/database/index.jsp">粤拼资料库&lt;/a>&lt;/p>
&lt;p>简单来讲，这三个韵尾的区别在于：&lt;/p>
&lt;ol>
&lt;li>&lt;code>-p&lt;/code> 要在嘴脣处阻断气流。如 垃圾 &lt;code>laap6 saap3&lt;/code>。在两个字的结尾，要将嘴脣闭合，以阻断气流。&lt;/li>
&lt;li>&lt;code>-t&lt;/code> 要在舌尖处阻断气流。如 佛 &lt;code>fat6&lt;/code>。在佛字的结尾，要用舌尖抵住牙齿阻断气流。&lt;/li>
&lt;li>&lt;code>-k&lt;/code> 要在舌根处阻断气流。如 白色 &lt;code>baak6 sik1&lt;/code>。在白和色这两个字的结尾，要用舌根抵住硬颚和软颚交界处阻断气流。&lt;/li>
&lt;/ol>
&lt;p>如果我们用更通俗一些的方式阐述，则是:&lt;/p>
&lt;p>&lt;strong>在粤拼中遇到这三个韵尾的时候，你需要分别做出英语中 p t k 的口型来阻断气流。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>这与英语口语中的尾音略有类似。例如&lt;code>keep&lt;/code>，不可能读成 &lt;code>ki pu&lt;/code>。最后的p会很轻很轻，并且不发音。&lt;/p>
&lt;/blockquote>
&lt;h2 id="补充">补充&lt;/h2>
&lt;p>但在我阅读一些其他的粤语教程的时候，发现有的教程的入声韵尾并不是用&lt;code>-p&lt;/code> &lt;code>-t&lt;/code> &lt;code>-k&lt;/code>这三个字母标记的。有些书用&lt;code>-b&lt;/code> &lt;code>-d&lt;/code> &lt;code>-g&lt;/code>这三个字母标注韵尾。其实这些标记方法在本质上是相同的。&lt;/p>
&lt;p>因为前面说过入声在粤语中是无声除阻音，也就是不发声。而&lt;code>p-b&lt;/code>，&lt;code>t-d&lt;/code>，&lt;code>k-g&lt;/code>之间的区别在于是否送气。
由于入声不需要声带振动，所以送气和不送气辅音可以视作等同的。&lt;/p>
&lt;p>举个例子，在韵尾为p的字中，收尾的时候无论你是摆&lt;code>b&lt;/code>的口型，还是摆&lt;code>p&lt;/code>的口型，是一样的。&lt;/p>
&lt;p>不过我们还是要以最流行的粤拼方案为准。这样可以少走一些弯路。&lt;/p>
&lt;h1 id="最后">最后&lt;/h1>
&lt;p>本文为Rise原创。如果有什么不准确的地方，欢迎各位在评论区指出。&lt;/p>
&lt;p>共同传承中华文化🥳&lt;/p>
&lt;h1 id="引用">引用&lt;/h1>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/%E7%B2%A4%E8%AF%AD">粤语 on Wikipedia&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/%E4%BA%94%E5%BA%A6%E6%A0%87%E8%AE%B0%E6%B3%95">五度标记法 on Wikipedia&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://input.foruto.com/ccc/jyt/005.htm">中文字元资料页&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.cantonese.asia/portal.php?mod=view&amp;amp;aid=229">粤语协会&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.iso10646hk.net/jp/learning/course_03.jsp">香港语言学学会粤语拼音方案&lt;/a>&lt;/p>
- https://risehere.net/2019/10/27/checked-tone-in-cantonese/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>2020年，在 Linux 下动手编译 OpenJDK 8</title><link>https://risehere.net/posts/building-openjdk/</link><pubDate>Tue, 05 May 2020 12:52:49 +0800</pubDate><guid>https://risehere.net/posts/building-openjdk/</guid><description>左手的世界 https://risehere.net/posts/building-openjdk/ -&lt;h1 id="前言">前言&lt;/h1>
&lt;p>这两天开始读深入理解 Java 虚拟机了。在这本书的第一章就提到了动手编译 OpenJDK。 &lt;del>突然想到 2018 年 11 月被 OpenCV 的交叉编译支配的恐惧。&lt;/del>&lt;/p>
&lt;p>网上的各种攻略琳琅满目，五花八门。&lt;/p>
&lt;p>终于，在蹚了前人的那些坑之后，我成功编译了 OpenJDK 8。其实编译一个 JDK 也没那么难。&lt;/p>
&lt;p>&amp;ndash; 即使是 2020 年，在更新策略&lt;strong>激进&lt;/strong>的 Arch 系 Linux 下，我没有降级任何软件也照样编译成功。&lt;/p>
&lt;blockquote>
&lt;p>注：本篇文章以 Manjaro Linux 为例进行讲解。其它的 Linux 基本一致，只是软件包名不同。&lt;/p>
&lt;/blockquote>
&lt;h1 id="准备">准备&lt;/h1>
&lt;h2 id="环境">环境&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th align="left">名称&lt;/th>
&lt;th align="left">版本&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td align="left">OS&lt;/td>
&lt;td align="left">Manjaro 20.0 Lysia&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Kernel&lt;/td>
&lt;td align="left">x86_64 Linux 4.19.118-1-MANJARO&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">make&lt;/td>
&lt;td align="left">GNU Make 4.3 x86_64-pc-linux-gnu&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">GCC&lt;/td>
&lt;td align="left">gcc (Arch Linux 9.3.0-1) 9.3.0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>注：我并没有切换到低版本的 gcc。&lt;/p>
&lt;/blockquote>
&lt;h2 id="openjdk-8">OpenJDK 8&lt;/h2>
&lt;p>你需要一个 OpenJDK 8 来编译 OpenJDK 8 原代码中的 Java 代码。太高或太低都不能编译成功。&lt;/p>
&lt;blockquote>
&lt;p>注： OpenJDK 7 理论上可以，但编译时会出问题。还是建议用 OpenJDK 8。&lt;/p>
&lt;/blockquote>
&lt;p>在 Arch Linux/Manjaro Linux 下，可以通过&lt;code>archlinux-java status&lt;/code>查看是否有 OpenJDK 8。输入以下命令：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ archlinux-java status | grep &lt;span style="color:#bd93f9">8&lt;/span>
java-8-openjdk
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果没有的话（即上面命令没有结果），赶紧去搞一个！（&lt;code>sudo pacman -S jdk8-openjdk&lt;/code>）&lt;/p>
&lt;h2 id="mercurial">Mercurial&lt;/h2>
&lt;p>作为 OpenJDK 的版本管理系统，类似于 git。&lt;/p>
&lt;p>在 Arch Linux 下可以通过 &lt;code>sudo pacman -S mercurial&lt;/code> 安装。&lt;/p>
&lt;p>（直接连接会很慢，请自行准备工具，具体工具请自行探索，支持 HTTP 代理就可以。下文会讲解如何给 mercurial 套 HTTP 代理。）&lt;/p>
&lt;blockquote>
&lt;p>注：本篇文章中提到的所有 sudo 操作都已经特别指出，不要在 sudo 模式下进行其它操作。&lt;/p>
&lt;/blockquote>
&lt;h2 id="gcc-和-make">GCC 和 make&lt;/h2>
&lt;p>这个貌似不用我多说。这个年头用 Linux 写代码，没个 &lt;code>gcc&lt;/code> 和 &lt;code>make&lt;/code> 好像还是一件挺尴尬的事情。&lt;/p>
&lt;p>（还是说一句：make 不是系统自带的，gcc 大多数自带，缺什么装什么。）&lt;/p>
&lt;h1 id="编译">编译&lt;/h1>
&lt;p>以上的工具准备好了，就可以开始编译了。&lt;/p>
&lt;h2 id="clone">clone&lt;/h2>
&lt;p>正常下载是&lt;code>hg clone 目标网址&lt;/code>。如果你的网络环境不好，可以出动 HTTP 代理。下例是让 mercurial 经过 http://127.0.0.1:8000/ 处的代理：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">hg --config http_proxy.host&lt;span style="color:#ff79c6">=&lt;/span>127.0.0.1:8000 clone http://hg.openjdk.java.net/jdk8u/jdk8u/
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="get_source">get_source&lt;/h2>
&lt;p>如果你的网络环境不好，我们要预先定义一下代理：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#8be9fd;font-style:italic">export&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">HGFOREST_GLOBALOPTS&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34; --config http_proxy.host=127.0.0.1:8000&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意：在&lt;code>--config&lt;/code>前有&lt;strong>一个空格&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;p>开始吧：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">chmod +x ./get_source.sh
./get_source.sh
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果中间失败，可以重复运行&lt;code>get_source.sh&lt;/code>，脚本会从失败的地方继续下载。&lt;/p>
&lt;blockquote>
&lt;p>注意：有些地方提到可以去 &lt;a href="http://jdk.java.net/">http://jdk.java.net/&lt;/a> 下载。但是我这里下载到的源代码都不能正常编译。&lt;/p>
&lt;/blockquote>
&lt;h2 id="configure">configure&lt;/h2>
&lt;p>输入以下命令开始配置工作。这里需要手动指定 Bootstrap JDK 的路径。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">./configure --with-boot-jdk&lt;span style="color:#ff79c6">=&lt;/span>/usr/lib/jvm/java-8-openjdk
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果没有报错，那么说明你的环境配置正常。&lt;/p>
&lt;h2 id="dirty-hack">dirty hack&lt;/h2>
&lt;p>我们还需要更改一下编译参数。OpenJDK 默认编译的时候会将所有 &lt;code>warning&lt;/code> 视为 &lt;code>error&lt;/code>，会导致以下错误：&lt;code>cc1plus: all warnings being treated as errors&lt;/code>&lt;/p>
&lt;p>因为 OpenJDK 8 的编译不支持 &lt;code>--disable-warnings-as-errors&lt;/code> 参数，所以我们需要&lt;strong>手动修改&lt;/strong>一下：&lt;/p>
&lt;p>打开&lt;code>./hotspot/make/linux/makefiles/gcc.make&lt;/code>，然后找到 &lt;code>WARNINGS_ARE_ERRORS =&lt;/code>，前面加&lt;code>#&lt;/code>，把这行&lt;strong>注释掉&lt;/strong>。&lt;/p>
&lt;h2 id="make">make&lt;/h2>
&lt;p>最后，可以正式编译了，分情况讨论。&lt;/p>
&lt;blockquote>
&lt;p>注：不需要指定 CPU 核心数。默认编译就是多核。&lt;/p>
&lt;/blockquote>
&lt;h3 id="仅编译">仅编译&lt;/h3>
&lt;p>如果只编译，不想要二进制：输入&lt;code>make&lt;/code>命令，开始编译。&lt;/p>
&lt;p>当你看到以下信息时，你就成功了：&lt;/p>
&lt;pre>&lt;code>## Finished jdk (build time 00:01:43)
----- Build times -------
Start 2020-05-05 13:14:42
End 2020-05-05 13:20:26
00:00:13 corba
00:03:23 hotspot
00:00:08 jaxp
00:00:11 jaxws
00:01:43 jdk
00:00:06 langtools
00:05:44 TOTAL
-------------------------
&lt;/code>&lt;/pre>&lt;h3 id="编译二进制">编译二进制&lt;/h3>
&lt;p>如果你想编译出 JDK JRE 的那套二进制的话，请运行&lt;code>make images&lt;/code>。&lt;/p>
&lt;p>此时结果应该是这样的：&lt;/p>
&lt;pre>&lt;code>## Finished images (build time 00:01:28)
----- Build times -------
Start 2020-05-05 19:36:50
End 2020-05-05 19:38:49
00:00:00 corba
00:00:16 demos
00:00:00 hotspot
00:01:28 images
00:00:01 jaxp
00:00:00 jaxws
00:00:05 jdk
00:00:01 langtools
00:00:08 nashorn
00:01:59 TOTAL
-------------------------
&lt;/code>&lt;/pre>&lt;p>这种情况下，你可以在&lt;code>./build/linux-x86_64-normal-server-release/images/j2sdk-image/bin/&lt;/code>目录下找到&lt;code>java&lt;/code>和&lt;code>javac&lt;/code>。&lt;/p>
&lt;p>你可以运行一下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ./java -version
openjdk version &lt;span style="color:#f1fa8c">&amp;#34;1.8.0-internal&amp;#34;&lt;/span>
OpenJDK Runtime Environment &lt;span style="color:#ff79c6">(&lt;/span>build 1.8.0-internal-amazingrise_2020_05_05_13_13-b00&lt;span style="color:#ff79c6">)&lt;/span>
OpenJDK 64-Bit Server VM &lt;span style="color:#ff79c6">(&lt;/span>build 25.71-b00, mixed mode&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>没错，它的版本号里写着你的机器名。 很有成就感。&lt;/p>
&lt;h1 id="最后">最后&lt;/h1>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>真的就这些了吗？是的，就这些。在 Linux 上，书上那一长串的&lt;code>export&lt;/code>统统不需要。&lt;/p>
&lt;p>而且可以看出，在我的普普通通的笔记本上，&lt;strong>不设置任何参数&lt;/strong>也可以很快完成编译。网上和书上的各种优化大可不必，&lt;code>configure&lt;/code>已经帮我们做好大部分了。&lt;/p>
&lt;blockquote>
&lt;p>尽信书不如无书。&lt;/p>
&lt;/blockquote>
&lt;p>有人可能会说这篇文章很水，但实际上我花了很多时间：我编译过 OpenJDK 7, 9, 11, 14，试了网上各种各样的方法都不行。&lt;/p>
&lt;p>就是希望后人少走点弯路吧（不走是不可能的）。&lt;/p>
&lt;p>另外，网上有人说，OpenJDK 8 编译巨坑，&lt;strong>其实也没那么复杂&lt;/strong>。（可能因为他是 macOS？）&lt;/p>
&lt;p>网上还有人说，怎么编译都不成功，把 Ubuntu 换成 CentOS 才行。我想说，&lt;strong>真的不至于&lt;/strong>。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>《深入理解 Java 虚拟机》周志明著，第二版。&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/desiyonan/article/details/80801991">问题整理 [已解决] - Debian10 下编译 OpenJDK-8 源码 - cc1plus: all warnings being treated as errors&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://bugs.openjdk.java.net/browse/JDK-8144695">&amp;ndash;disable-warnings-as-errors does not work for HotSpot build&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.jianshu.com/p/4e01daf8c357">osx环境编译jdk8&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/iou123lg/p/9696039.html">JVM-Ubuntu18.04.1下编译OpenJDK8&lt;/a>&lt;/p>
&lt;h2 id="次回予告">次回予告&lt;/h2>
&lt;p>下次可能是 &lt;code>NES 模拟器&lt;/code>或者&lt;code>简单 NLP 问答机器人&lt;/code>的实现了，看我有没有时间吧。&lt;/p>
- https://risehere.net/posts/building-openjdk/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>博客建立一周年纪念</title><link>https://risehere.net/posts/one-year-anniversary/</link><pubDate>Tue, 31 Mar 2020 23:08:27 +0800</pubDate><guid>https://risehere.net/posts/one-year-anniversary/</guid><description>左手的世界 https://risehere.net/posts/one-year-anniversary/ -&lt;p>今天，不是一周年整。无论是第一次发博文，还是网站开始运行，都不是完整的一周年。
但我已经迫不及待地想发博文，纪念我人生中第二个正儿八经的网站。&lt;/p>
&lt;p>同时，今天也是博客&lt;strong>深色模式&lt;/strong>上线的第一天，目前处于测试阶段，欢迎大家玩玩那个奇怪的按钮！&lt;/p>
&lt;p>还有，评论时留邮箱，会在有回复的时候自动发邮件提醒，欢迎大家留言。（来自&lt;code>no-reply At amazingrise.net&lt;/code>）&lt;/p>
&lt;p>（如何进入深色模式？手机版用户请看右上角的奇怪按钮，电脑版用户请看右下角的奇怪按钮）&lt;/p>
&lt;p>（如果你的浏览器支持深色模式，那么本页就会跟随浏览器设置，自动进入深色模式）&lt;/p>
&lt;h1 id="到访人数">到访人数&lt;/h1>
&lt;p>截止3月30日，已经有 2416 位不同的人到访过左手的世界，其中有 413 位是回头客。&lt;/p>
&lt;p>其中，有 1468 人使用 Chrome，220 人使用 Firefox。&lt;/p>
&lt;p>网站的总浏览量达到 1.04 万。&lt;/p>
&lt;h1 id="一些想法">一些想法&lt;/h1>
&lt;p>感觉有的时候灵感真的就是一瞬间，稍纵即逝。目前积压着的草稿有3篇，计划中但未开头的有2篇，有的估计已经写不出来了。&lt;/p>
&lt;p>所以如果大家脑子里有好的想法，一定要好好记下来，并且尽快实现它。&lt;/p>
&lt;h1 id="我的变化">我的变化&lt;/h1>
&lt;p>我在这一年里，学习了不少新技术，经历了不少事情，结交了不少朋友，思考也更加的多了。&lt;/p>
&lt;h2 id="低谷">低谷&lt;/h2>
&lt;p>过去的这一年，我经历了人生中的第 n 次低谷，并且沉迷于游戏中，试图逃避现实。当时的感觉就是信仰崩塌，世界观崩塌。&lt;/p>
&lt;p>不过当时有一首歌给我的鼓舞很大，我可以把这首歌的链接贴出来。（禁止外链播放，我也是很无奈）&lt;/p>
&lt;p>&lt;a href="https://music.163.com/song/3559782">A Rock &amp;lsquo;n&amp;rsquo; Roll Fantasy - The Kinks&lt;/a>&lt;/p>
&lt;p>这首歌讲的是：&lt;/p>
&lt;blockquote>
&lt;p>摇滚乐队面临解散，猫王已逝，时代终结，打算各奔东西。&lt;/p>
&lt;p>街区的一位伙伴，情绪低落之时沉浸于录制唱片。当他觉得世界对他关上大门，他就把音量调到最大，于是每日生活逃避现实，生活于摇滚狂想中。&lt;/p>
&lt;p>不过我不会像他一样就此罢休。我们也有过铁杆粉丝，见证我们成长，陪我们度过摇滚生涯中的巅峰与低潮。&lt;/p>
&lt;p>但我们总是胡思乱想，认为这个世界已经不需要我们了。我们不能生活在摇滚狂想中，我们不能活在现实的边缘。&lt;/p>
&lt;/blockquote>
&lt;p>在我最低落的时候，我反复听着这首歌。虽然对结果早有预料，但是还是感觉自己就像做梦一样。&lt;/p>
&lt;p>后来大概是时间抚平了一切。我找到了自己的定位，并且尝试积极面对生活。&lt;/p>
&lt;h2 id="新技术与新发现">新技术与新发现&lt;/h2>
&lt;p>这一年，我没少折腾新技术。在各种各样的机会，和给自己挖的各种坑里，我学会了很多东西。&lt;/p>
&lt;p>每次我自己造出来的东西，开始正常工作，都有一种说不出的奇怪的自豪感（奇怪大概是因为：哇这玩意居然能跑起来）。而面对一些牛逼的新技术，我不禁惊叹，原来代码还可以写得这么优美！&lt;/p>
&lt;p>对于新发现，我列不出来啦。我还是像以前一样，喜欢研究奇奇怪怪的东西，尤其各种各样语言方面的东西。比如我发了一篇关于粤语入声的博文。（不过囿于本人水平，这些东西也说不上是多么高深，跟真正研究相关内容的各位肯定是小巫见大巫了）&lt;/p>
&lt;p>同时，我还有做自媒体的想法。可惜现在时间不是很充裕，大概很难做大。&lt;/p>
&lt;h1 id="最后">最后&lt;/h1>
&lt;p>总结一下，过去的一年，有不满意的地方，也有让自己惊喜的地方。&lt;/p>
&lt;p>嗯。大概就是这么多话吧。如果有什么话想跟我说，欢迎评论区留言。&lt;/p>
&lt;p>（再说一遍，现在的评论区支持回复通知了，留下邮箱可以收到回复提醒哦）&lt;/p>
- https://risehere.net/posts/one-year-anniversary/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>初识 Vue 之 - 用 Vue 组件减少代码量</title><link>https://risehere.net/posts/getting-to-know-vue-components/</link><pubDate>Mon, 16 Mar 2020 10:12:18 +0800</pubDate><guid>https://risehere.net/posts/getting-to-know-vue-components/</guid><description>左手的世界 https://risehere.net/posts/getting-to-know-vue-components/ -&lt;h1 id="前言">前言&lt;/h1>
&lt;p>这又是一篇很基础很基础的文章。&lt;del>（因为我菜鸡呀.估计大佬们都去折腾算法分析什么的，只有我这个菜鸡还在天天搬砖，太难了。&lt;/del>&lt;/p>
&lt;p>本篇文章主要讲述如何用 Vue Components 减少重复代码量。&lt;/p>
&lt;h2 id="需求">需求&lt;/h2>
&lt;p>博客的友链页是由一个表格构成的：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>name&lt;/th>
&lt;th>url&lt;/th>
&lt;th>description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>张三&lt;/td>
&lt;td>&lt;a href="https://zhangsan.com">https://zhangsan.com&lt;/a>&lt;/td>
&lt;td>张三的挖坑日记&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>李四&lt;/td>
&lt;td>&lt;a href="https://lisi.com">https://lisi.com&lt;/a>&lt;/td>
&lt;td>李四的网络日志&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>不行，这太简陋了。如何编写一个更好的友链页呢？&lt;/p>
&lt;h1 id="实现">实现&lt;/h1>
&lt;p>那么我们就用 Bootstrap 的卡片来实现一个卡片式的友链页吧。&lt;/p>
&lt;h2 id="实现1-不用-vue">实现1 不用 Vue&lt;/h2>
&lt;p>下面我们用 Bootstrap 的卡片实现一个友链卡片。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-html" data-lang="html">&lt;span style="color:#6272a4">&amp;lt;!--为了使代码在这个例子中更加简洁，我暂且用 style 规定了一下卡片的宽度。--&amp;gt;&lt;/span>
&amp;lt;&lt;span style="color:#ff79c6">div&lt;/span> &lt;span style="color:#50fa7b">class&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;card&amp;#34;&lt;/span> &lt;span style="color:#50fa7b">style&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;width:20rem;&amp;#34;&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#ff79c6">div&lt;/span> &lt;span style="color:#50fa7b">class&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;card-body&amp;#34;&lt;/span>&amp;gt;
&lt;span style="color:#6272a4">&amp;lt;!-- 标题 --&amp;gt;&lt;/span>
&amp;lt;&lt;span style="color:#ff79c6">p&lt;/span> &lt;span style="color:#50fa7b">class&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;h4&amp;#34;&lt;/span>&amp;gt;张三&amp;lt;/&lt;span style="color:#ff79c6">p&lt;/span>&amp;gt;
&lt;span style="color:#6272a4">&amp;lt;!-- 描述 --&amp;gt;&lt;/span>
&amp;lt;&lt;span style="color:#ff79c6">p&lt;/span>&amp;gt;张三的挖坑日记&amp;lt;/&lt;span style="color:#ff79c6">p&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#ff79c6">div&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#ff79c6">div&lt;/span> &lt;span style="color:#50fa7b">class&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;card-footer&amp;#34;&lt;/span>&amp;gt;
&lt;span style="color:#6272a4">&amp;lt;!-- 链接 --&amp;gt;&lt;/span>
&amp;lt;&lt;span style="color:#ff79c6">a&lt;/span> &lt;span style="color:#50fa7b">href&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;https://zhangsan.com&amp;#34;&lt;/span>&amp;gt;https://zhangsan.com&amp;lt;/&lt;span style="color:#ff79c6">a&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#ff79c6">div&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#ff79c6">div&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>实现效果如下：&lt;/p>
&lt;div class="card" style="width:20rem;margin:1rem;">
&lt;div class="card-body">
&lt;p class="h4">张三&lt;/p>
&lt;p>张三的挖坑日记&lt;/p>
&lt;/div>
&lt;div class="card-footer">
&lt;a href="https://zhangsan.com">https://zhangsan.com&lt;/a>
&lt;/div>
&lt;/div>
&lt;p>这个做法有两个缺点：&lt;/p>
&lt;ol>
&lt;li>如果我们来了一位新的朋友，需要再次复制粘贴，这很不合理。&lt;/li>
&lt;li>如果我们需要修改卡片的样式，我们需要手动修改 n 次（n=朋友的个数）。&lt;/li>
&lt;/ol>
&lt;h2 id="实现2-vue-app">实现2 Vue App&lt;/h2>
&lt;p>引入 Vue，利用&lt;code>v-for&lt;/code>我们可以提高代码的复用性。&lt;/p>
&lt;p>先定义一个 Vue App，然后把朋友们以数组的形式录入 &lt;code>data&lt;/code> 中。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> app &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Vue({
el&lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;#app&amp;#39;&lt;/span>,
data&lt;span style="color:#ff79c6">:&lt;/span> {
friends&lt;span style="color:#ff79c6">:&lt;/span> [
{
name&lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;张三&amp;#34;&lt;/span>,
description&lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;张三的挖坑日记&amp;#34;&lt;/span>,
url&lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;https://zhangsan.com/&amp;#34;&lt;/span>
},
{
name&lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;李四&amp;#34;&lt;/span>,
description&lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;李四的网络日志&amp;#34;&lt;/span>,
url&lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;https://lisi.com/&amp;#34;&lt;/span>
}
]
}
})&lt;span style="color:#ff79c6">&amp;lt;&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后我们用&lt;code>v-for&lt;/code>遍历一下&lt;code>friends&lt;/code>这个元素。&lt;/p>
&lt;div v-pre>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-html" data-lang="html">&amp;lt;&lt;span style="color:#ff79c6">div&lt;/span> &lt;span style="color:#50fa7b">id&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;app&amp;#34;&lt;/span>&amp;gt;
&lt;span style="color:#6272a4">&amp;lt;!-- 在这里用 v-for 遍历数组内容，其实它是一个 foreach --&amp;gt;&lt;/span>
&amp;lt;&lt;span style="color:#ff79c6">div&lt;/span> &lt;span style="color:#50fa7b">class&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;card&amp;#34;&lt;/span> &lt;span style="color:#50fa7b">style&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;width:20rem;&amp;#34;&lt;/span> &lt;span style="color:#50fa7b">v-for&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;friend in friends&amp;#34;&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#ff79c6">div&lt;/span> &lt;span style="color:#50fa7b">class&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;card-body&amp;#34;&lt;/span>&amp;gt;
&lt;span style="color:#6272a4">&amp;lt;!-- 标题 --&amp;gt;&lt;/span>
&amp;lt;&lt;span style="color:#ff79c6">p&lt;/span> &lt;span style="color:#50fa7b">class&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;h4&amp;#34;&lt;/span>&amp;gt;{{friend.name}}&amp;lt;/&lt;span style="color:#ff79c6">p&lt;/span>&amp;gt;
&lt;span style="color:#6272a4">&amp;lt;!-- 描述 --&amp;gt;&lt;/span>
&amp;lt;&lt;span style="color:#ff79c6">p&lt;/span>&amp;gt;{{friend.description}}&amp;lt;/&lt;span style="color:#ff79c6">p&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#ff79c6">div&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#ff79c6">div&lt;/span> &lt;span style="color:#50fa7b">class&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;card-footer&amp;#34;&lt;/span>&amp;gt;
&lt;span style="color:#6272a4">&amp;lt;!-- 链接，注意 这个地方要用v-bind:href --&amp;gt;&lt;/span>
&amp;lt;&lt;span style="color:#ff79c6">a&lt;/span> &lt;span style="color:#50fa7b">v-&lt;/span> &lt;span style="color:#50fa7b">bind:href&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;friend.url&amp;#34;&lt;/span>&amp;gt;{{friend.url}}&amp;lt;/&lt;span style="color:#ff79c6">a&lt;/span>&amp;gt;
&lt;span style="color:#6272a4">&amp;lt;!-- 关于这一点请参见 https://cn.vuejs.org/v2/guide/syntax.html#Attribute --&amp;gt;&lt;/span>
&lt;span style="color:#6272a4">&amp;lt;!-- v-bind 也可以缩写为 `:url=&amp;#34;friend.url&amp;#34;` 。 --&amp;gt;&lt;/span>
&amp;lt;/&lt;span style="color:#ff79c6">div&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#ff79c6">div&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#ff79c6">div&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样可以复用卡片代码，并且修改样式也很方便了。&lt;/p>
&lt;p>但这个代码还是不完美：&lt;/p>
&lt;ol>
&lt;li>首先，如果你有个新的朋友，却需要修改 Vue App 的 &lt;code>data&lt;/code> 属性。为了 HTML 内容而修改 Javascript 是很不合理的。我们需要给 Javascript 和 HTML 解藕。&lt;/li>
&lt;li>不过为这一个页面开一个 Vue App 是不是有点小题大作呢？ 而且更重要的一点是，一山不容二虎，嵌套 Vue App 会导致奇怪的 Bug。&lt;del>（禁止套娃&lt;/del>&lt;/li>
&lt;/ol>
&lt;/div>
&lt;h2 id="实现3-vue-组件">实现3 Vue 组件&lt;/h2>
&lt;blockquote>
&lt;p>How can we do better?&lt;/p>
&lt;/blockquote>
&lt;div v-pre>
&lt;p>如果有这么一种写法，就比较完美了：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-html" data-lang="html">&amp;lt;&lt;span style="color:#ff79c6">friend&lt;/span> &lt;span style="color:#50fa7b">description&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;张三的挖坑日记&amp;#34;&lt;/span> &lt;span style="color:#50fa7b">url&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;https://zhangsan.com&amp;#34;&lt;/span>&amp;gt;张三&amp;lt;/&lt;span style="color:#ff79c6">friend&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#ff79c6">friend&lt;/span> &lt;span style="color:#50fa7b">description&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;李四的网络日志&amp;#34;&lt;/span> &lt;span style="color:#50fa7b">url&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;https://lisi.com&amp;#34;&lt;/span>&amp;gt;李四&amp;lt;/&lt;span style="color:#ff79c6">friend&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>很幸运的是，Vue.js 提供这种功能。&lt;/p>
&lt;p>我们可以定义一个 Vue Component。这里要引入两样东西：&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://cn.vuejs.org/v2/guide/components-slots.html">slot&lt;/a> 写在模板中，用来插入标签中间的数据，即&lt;code>&amp;lt;friend&amp;gt;&amp;lt;/friend&amp;gt;&lt;/code>中间的内容。&lt;/li>
&lt;li>&lt;a href="https://cn.vuejs.org/v2/guide/components-props.html">props&lt;/a> 用于提取标签属性中的数据，如&lt;code>&amp;lt;friend url=&amp;quot;xxx&amp;quot;...&lt;/code>。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">Vue.component(&lt;span style="color:#f1fa8c">&amp;#39;friend&amp;#39;&lt;/span>,{
&lt;span style="color:#6272a4">// 注意一定要在这里定义 props，否则会提示 not defined 的问题。
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> props&lt;span style="color:#ff79c6">:&lt;/span>[&lt;span style="color:#f1fa8c">&amp;#39;url&amp;#39;&lt;/span>,&lt;span style="color:#f1fa8c">&amp;#39;description&amp;#39;&lt;/span>],
template&lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">`
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;lt;div class=&amp;#34;card&amp;#34; style=&amp;#34;width:20rem;&amp;#34;&amp;gt;
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;lt;div class=&amp;#34;card-body&amp;#34;&amp;gt;
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;lt;!-- 标题，这里用了slot，目的是在这里插入“&amp;lt;friend&amp;gt;这里&amp;lt;/friend&amp;gt;”的内容。 --&amp;gt;
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;lt;p class=&amp;#34;h4&amp;#34;&amp;gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&amp;lt;/p&amp;gt;
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;lt;!-- 描述，这里就是对“&amp;lt;friend description=&amp;#34;这里&amp;#34;...”内容的提取。 --&amp;gt;
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;lt;p&amp;gt;{{ description }}&amp;lt;/p&amp;gt;
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;lt;/div&amp;gt;
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;lt;div class=&amp;#34;card-footer&amp;#34;&amp;gt;
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;lt;!-- 链接，同理，这个我就不用解释了。注意这里也要用 v-bind --&amp;gt;
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;lt;a v-bind:href=&amp;#34;url&amp;#34;&amp;gt;{{url}}&amp;lt;/a&amp;gt;
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;lt;!-- v-bind 也可以缩写为 :url=&amp;#34;friend.url&amp;#34; 。 --&amp;gt;
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;lt;/div&amp;gt;
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;lt;/div&amp;gt;
&lt;/span>&lt;span style="color:#f1fa8c"> `&lt;/span>
});
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样我们就实现了一个可复用的 Vue 组件了，而且上面的问题我们已经完美解决了：&lt;/p>
&lt;ol>
&lt;li>如果我们新增了一个朋友，就只需要在页面相应地方里面写一句：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-html" data-lang="html">&amp;lt;&lt;span style="color:#ff79c6">friend&lt;/span> &lt;span style="color:#50fa7b">description&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;描述&amp;#34;&lt;/span> &lt;span style="color:#50fa7b">url&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;网址&amp;#34;&lt;/span>&amp;gt;朋友的名字&amp;lt;/&lt;span style="color:#ff79c6">friend&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>
&lt;p>Vice versa，如果我们需要修改卡片的样式，我们只需要修改组件的 &lt;code>template&lt;/code> 里面的代码（当然你可以进一步将 CSS 分离出来）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本方法用的是 Vue 组件，它不会与原有的 Vue App 冲突（不过组件必须要写在 Vue App 里面。）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;h1 id="参考">参考&lt;/h1>
&lt;p>&lt;strong>如果你对上文所说内容仍有疑惑，可以翻看下面的链接。&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.runoob.com/bootstrap4/bootstrap4-cards.html">Bootstrap 4 卡片 菜鸟教程&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://cn.vuejs.org/v2/guide/syntax.html#Attribute">Vue - 模板语法 和 Attribute&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://cn.vuejs.org/v2/guide/components-slots.html">Vue - 组件模板中插槽的使用&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://cn.vuejs.org/v2/guide/components-props.html">Vue - 组件的 props 属性&lt;/a>&lt;/p>
&lt;h1 id="后记">后记&lt;/h1>
&lt;p>复制粘贴永远都是愚蠢的做法，而反人类的设计早有一日会被崭新的设计替代。&lt;/p>
&lt;blockquote>
&lt;p>How can we do better?&lt;/p>
&lt;/blockquote>
&lt;p>这句话是 Robert Sedgewick 老先生在算法公开课里面经常提到的。只有不断思考&lt;code>How can we do better&lt;/code>，认知才会不断提高。否则对着一个愚蠢的做法沾沾自喜，永远不会有进步。&lt;/p>
&lt;p>另外有问题的话，欢迎在评论区交流。&lt;/p>
- https://risehere.net/posts/getting-to-know-vue-components/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>今天你是锦鲤吗</title><link>https://risehere.net/posts/koi-carp-scam/</link><pubDate>Sun, 16 Feb 2020 12:29:40 +0800</pubDate><guid>https://risehere.net/posts/koi-carp-scam/</guid><description>左手的世界 https://risehere.net/posts/koi-carp-scam/ -&lt;h1 id="前言">前言&lt;/h1>
&lt;p>&lt;em>本人多年前毕业于某 985 高校的信息安全专业。另外，本站受 Cloudflare CDN 的防护。&lt;/em>&lt;/p>
&lt;p>引用一句烂大街名人名言(不过确实有道理)&lt;/p>
&lt;blockquote>
&lt;p>命运赠予的礼物，早已在暗中标好了价格。&lt;/p>
&lt;/blockquote>
&lt;p>今天你是锦鲤吗? 不是。以后也不会是。&lt;/p>
&lt;h1 id="结论">结论&lt;/h1>
&lt;p>考虑到一些读者可能对长篇大论产生恐惧，在此我先亮出结论:&lt;/p>
&lt;ul>
&lt;li>每一次锦鲤转发都为商家做了免费推广。&lt;/li>
&lt;li>中了奖，不但为商家做了免费的宣传，而且个人信息将会无偿奉献给商家。
&lt;ul>
&lt;li>如果是正规商家，活生生的人将会变成商家的&amp;quot;优质推广机器&amp;rdquo;，以后没准有&amp;quot;好事&amp;quot;还会找上门。&lt;/li>
&lt;li>如果是搞辣鸡营销的，手机号将会在黑市上标好价格被批发，并且反复倒卖。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>可见，无论是哪条路，说到底，锦鲤活动还是商家赚钱的手段。&lt;/p>
&lt;p>我们还是要擦亮自己的眼睛，吃一堑长一智。 &lt;del>毕竟我也是这么走过来的。&lt;/del>&lt;/p>
&lt;p>&lt;em>各位息怒啊，不要打我。消消气往下看。&lt;/em>&lt;/p>
&lt;h1 id="正文">正文&lt;/h1>
&lt;p>今天早上一醒来，就又被微信朋友圈的某一爆款锦鲤文章刷屏了:&lt;code>寻找某某高校不出门锦鲤，10000元奖品独宠你!&lt;/code>。&lt;/p>
&lt;p>其实我相信大家的心是好的，在家不出门也是为抗击疫情做贡献，还能顺便抽个奖，万一中了呢?&lt;/p>
&lt;p>实际上这是一个精心策划的营销活动，并且天上不会掉馅饼，看似免费的转发也&lt;strong>付出了一定代价&lt;/strong>。&lt;/p>
&lt;p>下面我将分解一下它的&lt;strong>千层套路&lt;/strong>。&lt;/p>
&lt;h2 id="渣男行为">渣男行为&lt;/h2>
&lt;p>这种抽奖其实是渣男行为。我们看一下标题，&lt;code>寻找某某高校不出门锦鲤&lt;/code>。&lt;/p>
&lt;p>这个标题可能会产生以下误导:&lt;/p>
&lt;ul>
&lt;li>该活动是商家跟学校联合推出的活动。&lt;/li>
&lt;li>商家只独宠我们高校嘻嘻嘻为母校自豪。&lt;/li>
&lt;/ul>
&lt;p>首先，学校肯定是不会接这样的赞助恰烂钱，学校&lt;strong>不缺这点钱&lt;/strong>，尤其是985/211工程院校。并且据老同学(曾经担任过社团社长)透露，学校也是禁止社团拉这样的赞助的。所以，学校不可能跟商家联合推出这样的活动，这只是商家为了增加可信度所加上的谎言。&lt;/p>
&lt;p>第二，这种&lt;code>套近乎&lt;/code>的手段其实屡见不鲜。要戳破这个谎言也很简单：我们打开其中的某一篇推文。查看一下阅读量。以今天早上我看到的这篇推文为例，阅读量只有&lt;strong>9800&lt;/strong>。然后我们关注一下公众号，按照他们说的办法，我们找到了&amp;quot;抽奖助手&amp;quot;小程序二维码。扫码进入，发现参与抽奖人数是&lt;strong>2w&lt;/strong>。这说明什么?(doge&lt;/p>
&lt;p>其实我们也可以直接利用微信的搜一搜功能，以关键词&lt;code>寻找 大学 不出门 锦鲤&lt;/code>查找，便会找到 n 多一模一样，只是大学名字换了的推文:&lt;/p>
&lt;p>&lt;img src="search_result.jpg" alt="" />&lt;/p>
&lt;p>所以，推文推给的，并不是&amp;quot;被独宠的那个ta&amp;rdquo;。我们只是商家 &lt;strong>&amp;ldquo;广撒网&amp;quot;的猎物&lt;/strong>。&lt;/p>
&lt;p>更何况，这些活动往年就有几乎一模一样的东西。第二年出来换个外衣，说个校庆，或者是蹭疫情热度，来个换汤不换药的推文。&lt;/p>
&lt;h2 id="分母的秘密">分母的秘密&lt;/h2>
&lt;p>当商家广撒网，撒到了自己的朋友圈里。很多人看到了会调侃一下，说当个分母吧！（&lt;em>请勿对号入座&lt;/em>）于是点开了推文，抱着“当个分母反正也不花钱”的心理，虔诚转发。（对于免费背后的危机，将会在下文展开分析。）&lt;/p>
&lt;p>这种抽奖行为一般具有以下几种要素：&lt;/p>
&lt;ol>
&lt;li>奖品金额很大。&lt;/li>
&lt;li>关注公众号，点点转发就可以参与抽奖。&lt;/li>
&lt;li>中奖率很低。&lt;/li>
&lt;/ol>
&lt;p>我们来分析一下这几点。&lt;/p>
&lt;p>对于&lt;code>第一点&lt;/code>，奖品金额很大，对于人们有很大的诱惑力。而&lt;code>第二点&lt;/code>，基本是不花费什么明显的成本，只需要轻松关注+转发，便可以坐等巨型锦鲤砸到头上。怎么算都是一笔很划算的账。&lt;/p>
&lt;p>面对推文，一部分人看到这里的时候，心理可能还留存着一些顾虑：万一没有中奖，转发岂不是很丢人？而&lt;code>第三点&lt;/code>成功打消了他们&lt;strong>最后的顾虑&lt;/strong>：本来这就是中奖率很低的抽奖，我转发仅仅是出于“玩一下”的目的，所以没中也没关系啦。&lt;/p>
&lt;p>这便是&lt;strong>分母的秘密&lt;/strong>，中奖率很低，但奖品金额很大，参与成本很低。即使没中奖，&lt;strong>也不会丢面子&lt;/strong>，分母们也乐在其中。&lt;/p>
&lt;h2 id="免费的代价">免费的代价&lt;/h2>
&lt;p>有人可能会说：&lt;/p>
&lt;blockquote>
&lt;p>他渣不渣男，我当不当分母，我都不管。万一我中了呢，岂不是血赚。 &amp;ldquo;噫，我中了。&amp;quot;(范进中举.jpg)&lt;/p>
&lt;/blockquote>
&lt;p>但是，无奸不商。任何看似血赚的活动，除非是商家脑子抽了，&lt;strong>绝不会让你血赚&lt;/strong>。转发推文的行为实际上免费帮他们做了以下的宣传推广：&lt;/p>
&lt;hr />
&lt;ol>
&lt;li>免费的公众号推广&lt;/li>
&lt;/ol>
&lt;p>抽奖的先决条件就是&lt;code>关注这个公众号&lt;/code>，很多情况下关注了就关注了，除非它天天推恰烂钱推文，才会特地点一下&lt;code>取消关注&lt;/code>。&lt;/p>
&lt;p>关注公众号的好处：万一某天推文里提到的商品正好是当事人感兴趣的（例如网课，书籍等），再加上常见的贩卖焦虑的套路，他们就会成功把产品推销出去。&lt;/p>
&lt;ol start="2">
&lt;li>免费筛选受众&lt;/li>
&lt;/ol>
&lt;p>该推文面对的群体是大学生，大学生有一定的经济能力，他们能为喜欢的商品买单，而不会过多怀疑。这便属于优质群体。所以经过这次活动，他们免费让这些大学生关注了公众号，实现了优质受众的筛选与引流，即从 &lt;code>朋友圈&lt;/code> 到 &lt;code>公众号&lt;/code> 的引流。（引 流 之 主）&lt;/p>
&lt;p>（下文还有进一步引流。）&lt;/p>
&lt;ol start="3">
&lt;li>免费提高曝光率&lt;/li>
&lt;/ol>
&lt;p>从传媒的角度分析，在朋友圈的一次转发可以增加该条推文的&lt;strong>曝光率&lt;/strong>。&lt;/p>
&lt;p>朋友圈的多次转发，曝光率高，增强了&lt;code>曝光效应&lt;/code>:一件事物对于同一个人，展现的次数越多，越容易让人放松警惕，让人在潜意识中觉得是安全的。&lt;/p>
&lt;p>并且朋友圈基本上代表了主人的立场。 一次朋友圈转发，基本等同此人对内容的认可。其他人一看，哟吼，某位朋友发的，我也转一转，由此引发连锁式的推广。故转发人也与此同时&lt;strong>消费了自己的信用&lt;/strong>。&lt;/p>
&lt;p>&lt;em>大家还可以看看财经类的大v的关于类似营销的分析，他们会比我专业的多。(包括什么瑞幸咖啡啊，天猫双十一啊，这些都是商家早早就算好的账，就等大家来买了。)&lt;/em>&lt;/p>
&lt;hr />
&lt;p>转发人&lt;strong>花费自己的信用&lt;/strong>，在&lt;strong>优质的社交圈子&lt;/strong>，为商家做&lt;strong>无形而免费的链式宣传&lt;/strong>。估计商家做梦都能笑出声来。&lt;/p>
&lt;p>此外，我知道耐心看到这里的朋友你一定也很&lt;strong>优秀&lt;/strong>，所以你的朋友圈一定是优质的社交圈子。当然就更不能轻易转发这些东西啦。&lt;/p>
&lt;h2 id="中奖之后">中奖之后&lt;/h2>
&lt;p>开奖时间到了，让我康康是谁中奖了？&lt;/p>
&lt;p>OHHHHHHHHH~ 没错，这位同学就是幸运观众，他就是天选之子！经过前面的虔诚转发，终于锦鲤砸到了他头上。商家通知他中奖了。下面请这位同学发言：&lt;/p>
&lt;blockquote>
&lt;p>感谢气象台，感谢爸爸妈妈。这好事一桩啊。呵，之前那个谁，那个叫 Rise 的家伙还劝我不要抽奖。你看我中奖了你酸不酸？&lt;/p>
&lt;/blockquote>
&lt;p>我不酸。后面还有戏。&lt;/p>
&lt;p>中奖之后，不可避免要提供自己的个人信息。这里我们需要分类讨论一下。&lt;/p>
&lt;h3 id="正规商家">正规商家&lt;/h3>
&lt;p>如果是正规商家，这位同学将会成为优质客户中的优质客户。因为经历过这次抽奖，由于&lt;code>晕轮效应&lt;/code>，这位同学可能对这家公司充满了好感，所以将来如果还有类似的活动，他也很大概率会积极参加。经历了前文所述的一系列帮忙推广，商家&lt;strong>花点小钱&lt;/strong>，卖点奖品犒劳一下这位同学也无妨。&lt;/p>
&lt;p>此外，商家会让你注册他们的平台，这样成功实现了从 &lt;code>微信公众号&lt;/code> 到 &lt;code>客户端&lt;/code> 的引流。要知道，推荐一位用户注册客户端，就拥有了更多的推送机会。&lt;/p>
&lt;h3 id="黑心商家">黑心商家&lt;/h3>
&lt;p>如果是黑心商家就惨了。除了上文提到的结果之外，附加buff有很多：轻则个人信息被规模批发，反复倒卖，重则被骗各种手续费（下文详述）。&lt;/p>
&lt;p>我知道很多人对于这些不以为然，只要不交钱，我就不会上当。实际上手机号在当今的社会太重要了，尤其是如今手机号与个人一一绑定，各种需要实名验证的场合都不需要验证身份证，只需要绑定你的手机号就可以了。所以一定程度上来讲，&lt;strong>你的手机号几乎等于身份证&lt;/strong>。&lt;/p>
&lt;h2 id="发奖过程中">发奖过程中&lt;/h2>
&lt;p>这里是对于黑心商家的阐述。对于无良商家，在发奖过程中可能会搞出以下事情：&lt;/p>
&lt;ol>
&lt;li>仅仅骗取个人信息，将得到的个人信息批发，反复倒卖。或者掺杂一半以往活动的个人信息，再卖出去一次。个人信息像商品一样，被毫无尊严地卖来卖去。&lt;/li>
&lt;li>声称免费抽奖，却让你注册某p2p平台，存一笔钱，到指定时间后可提现。至于危害，你上网搜索一下&lt;code>p2p暴雷&lt;/code>。（钱没了，甚至卷入黑产）&lt;/li>
&lt;li>声称免费，但以各种手续费，海关扣留费用为由，迟迟不发货，等你打钱。这个大家只要不汇钱就不会上当。（有一说一，这已经不是主流诈骗手段了。）&lt;/li>
&lt;/ol>
&lt;p>以上说的是常见骗术。当然，其他骗术以后肯定也会层出不穷。希望大家能够擦亮眼睛，远离骗局~&lt;/p>
&lt;h1 id="最后">最后&lt;/h1>
&lt;p>感谢能耐心看到最后的读者们。这篇文章花费了我一天的时间写成，只为让大家远离这些骗局，实是为大家着想。&lt;/p>
&lt;p>如有冒犯，请各位原谅。我知道我这样的行为也很不讨好。我觉得只要能让大家远离骗局，这篇文章就不白写。哪怕是你把我拉黑了，换你今后的不上当，我也值了。&lt;/p>
&lt;p>营销套路千千万，希望大家永不上当。（“永不上当”梗来自春晚，见下图）&lt;/p>
&lt;p>&lt;img src="never_cheated.gif" alt="" />&lt;/p>
&lt;p>本篇文章不欢迎不署名转载，但欢迎转发。&lt;/p>
- https://risehere.net/posts/koi-carp-scam/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>OBS Studio 显示正在播放的歌曲 in Linux</title><link>https://risehere.net/posts/obs-now-playing/</link><pubDate>Sun, 12 Jan 2020 11:22:20 +0800</pubDate><guid>https://risehere.net/posts/obs-now-playing/</guid><description>左手的世界 https://risehere.net/posts/obs-now-playing/ -&lt;h1 id="前言">前言&lt;/h1>
&lt;h2 id="前言的前言">前言的前言&lt;/h2>
&lt;p>欢迎大家关注我的 bilibili 帐号：&lt;a href="https://space.bilibili.com/441928938/">bili-Amazingrise&lt;/a>&lt;/p>
&lt;p>不定期直播搬砖，游戏，或者其他有趣的东西~&lt;/p>
&lt;h2 id="缘由">缘由&lt;/h2>
&lt;p>为了能在直播的时候，显示我正在播放的歌曲，我想了很多的方法。&lt;/p>
&lt;p>看到了 KDE Connect 里面能显示正在播放的歌曲，我觉得一定可以很容易地获取到当前媒体的状态信息。&lt;/p>
&lt;p>另外，这篇文章的诞生也是受到这位的启发：&lt;a href="https://keep.moe/2019/05/16/netease-now-playing-lldb/">获取 macOS 网易云音乐的正在播放 —— 使用 LLDB 验证思路 &lt;/a>
（没错，就是这个主题的原作者。）&lt;/p>
&lt;h1 id="正文">正文&lt;/h1>
&lt;h2 id="原理">原理&lt;/h2>
&lt;p>当然，我们的 Linux 没有那么复杂，用一个 Shell 脚本就能读取到当前播放的媒体。&lt;/p>
&lt;p>由于 OBS Studio 支持从文本文件读取文字内容，并且显示在输出流上，我们可以用 Shell 脚本先读出当前播放的媒体信息，然后再将它写入某个文件里，最后让 OBS Studio 读取这个文件就可以了。&lt;/p>
&lt;p>以我用的 &lt;a href="https://github.com/Rocket1184/electron-netease-cloud-music">Electron Netease Cloud Music&lt;/a> 为例。&lt;/p>
&lt;p>在 Linux 中，显示正在播放是通过调用 dbus mpris API 实现的。&lt;/p>
&lt;p>仔细看该项目的源代码，可以找到&lt;a href="https://github.com/Rocket1184/electron-netease-cloud-music/blob/master/src/main/mpris/mpris.js#L14">这几行&lt;/a>：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#ff79c6">const&lt;/span> i &lt;span style="color:#ff79c6">=&lt;/span> {
name(suffix) {
&lt;span style="color:#ff79c6">if&lt;/span> (suffix) &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#f1fa8c">`org.mpris.MediaPlayer2.&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>suffix&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">`&lt;/span>;
&lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;org.mpris.MediaPlayer2&amp;#39;&lt;/span>;
},
path(suffix) {
&lt;span style="color:#ff79c6">if&lt;/span> (suffix) &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#f1fa8c">`/org/mpris/MediaPlayer2/&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>suffix&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">`&lt;/span>;
&lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;/org/mpris/MediaPlayer2&amp;#39;&lt;/span>;
}
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以获取到它的 dbus 路径(?暂且这么称呼)，这个在后面会有用。&lt;/p>
&lt;p>那么当前媒体的元数据(metadata)的形式是怎么样的呢？&lt;/p>
&lt;p>于是我们用上面获取到的 dbus 路径，来获取到当前媒体的元数据。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">dbus-send --print-reply --dest&lt;span style="color:#ff79c6">=&lt;/span>org.mpris.MediaPlayer2.ElectronNCM /org/mpris/MediaPlayer2 org.freedesktop.DBus.Properties.Get string:org.mpris.MediaPlayer2.Player string:Metadata
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后我们会得到这样一段结果：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">method &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>1578801147.817851 &lt;span style="color:#8be9fd;font-style:italic">sender&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>:1.89 -&amp;gt; &lt;span style="color:#8be9fd;font-style:italic">destination&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>:1.303 &lt;span style="color:#8be9fd;font-style:italic">serial&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#bd93f9">100&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">reply_serial&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#bd93f9">2&lt;/span>
variant array &lt;span style="color:#ff79c6">[&lt;/span>
dict entry&lt;span style="color:#ff79c6">(&lt;/span>
string &lt;span style="color:#f1fa8c">&amp;#34;mpris:trackid&amp;#34;&lt;/span>
variant object path &lt;span style="color:#f1fa8c">&amp;#34;/org/mpris/MediaPlayer2/1475050&amp;#34;&lt;/span>
&lt;span style="color:#ff79c6">)&lt;/span>
dict entry&lt;span style="color:#ff79c6">(&lt;/span>
string &lt;span style="color:#f1fa8c">&amp;#34;mpris:length&amp;#34;&lt;/span>
variant int64 &lt;span style="color:#bd93f9">164000000&lt;/span>
&lt;span style="color:#ff79c6">)&lt;/span>
dict entry&lt;span style="color:#ff79c6">(&lt;/span>
string &lt;span style="color:#f1fa8c">&amp;#34;mpris:artUrl&amp;#34;&lt;/span>
variant string &lt;span style="color:#f1fa8c">&amp;#34;https://p1.music.126.net/QfpBYZjsztHjucFAIxfDgQ==/1746024464908302.jpg&amp;#34;&lt;/span>
&lt;span style="color:#ff79c6">)&lt;/span>
dict entry&lt;span style="color:#ff79c6">(&lt;/span>
string &lt;span style="color:#f1fa8c">&amp;#34;xesam:album&amp;#34;&lt;/span>
variant string &lt;span style="color:#f1fa8c">&amp;#34;Working Class Hero: The Definitive Lennon&amp;#34;&lt;/span>
&lt;span style="color:#ff79c6">)&lt;/span>
dict entry&lt;span style="color:#ff79c6">(&lt;/span>
string &lt;span style="color:#f1fa8c">&amp;#34;xesam:artist&amp;#34;&lt;/span>
variant array &lt;span style="color:#ff79c6">[&lt;/span>
string &lt;span style="color:#f1fa8c">&amp;#34;John Lennon&amp;#34;&lt;/span>
&lt;span style="color:#ff79c6">]&lt;/span>
&lt;span style="color:#ff79c6">)&lt;/span>
dict entry&lt;span style="color:#ff79c6">(&lt;/span>
string &lt;span style="color:#f1fa8c">&amp;#34;xesam:discNumber&amp;#34;&lt;/span>
variant int16 &lt;span style="color:#bd93f9">0&lt;/span>
&lt;span style="color:#ff79c6">)&lt;/span>
dict entry&lt;span style="color:#ff79c6">(&lt;/span>
string &lt;span style="color:#f1fa8c">&amp;#34;xesam:title&amp;#34;&lt;/span>
variant string &lt;span style="color:#f1fa8c">&amp;#34;Oh My Love&amp;#34;&lt;/span>
&lt;span style="color:#ff79c6">)&lt;/span>
dict entry&lt;span style="color:#ff79c6">(&lt;/span>
string &lt;span style="color:#f1fa8c">&amp;#34;xesam:trackNumber&amp;#34;&lt;/span>
variant int16 &lt;span style="color:#bd93f9">9&lt;/span>
&lt;span style="color:#ff79c6">)&lt;/span>
&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>从结果中我们可以找到我们想要的信息：歌手，标题等等。&lt;/p>
&lt;p>最后，我们只需要用正则表达式提取一下就🉑️️了。&lt;/p>
&lt;h2 id="实现">实现&lt;/h2>
&lt;p>正则表达式 &lt;del>当时鼓捣了好久，&lt;/del> 能用就行。&lt;/p>
&lt;p>下面是具体的 Shell 脚本实现。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#6272a4">#/bin/sh!&lt;/span>
&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Song Daemon is running......&amp;#34;&lt;/span>
&lt;span style="color:#8be9fd;font-style:italic">PREFIX&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;Rise 正在播放:&amp;#34;&lt;/span>
&lt;span style="color:#8be9fd;font-style:italic">FILENAME&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;/tmp/songdaemon&amp;#34;&lt;/span>
&lt;span style="color:#8be9fd;font-style:italic">NOSONG&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;当前没有播放歌曲&amp;#34;&lt;/span>
&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$NOSONG&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> &amp;gt; &lt;span style="color:#8be9fd;font-style:italic">$FILENAME&lt;/span>
&lt;span style="color:#ff79c6">while&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span> : &lt;span style="color:#ff79c6">]&lt;/span>
&lt;span style="color:#ff79c6">do&lt;/span>
&lt;span style="color:#8be9fd;font-style:italic">ARTIST&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>dbus-send --print-reply --dest&lt;span style="color:#ff79c6">=&lt;/span>org.mpris.MediaPlayer2.ElectronNCM /org/mpris/MediaPlayer2 org.freedesktop.DBus.Properties.Get string:org.mpris.MediaPlayer2.Player string:Metadata | sed -n &lt;span style="color:#f1fa8c">&amp;#39;/artist/{n;n;p}&amp;#39;&lt;/span> | cut -d &lt;span style="color:#f1fa8c">&amp;#39;&amp;#34;&amp;#39;&lt;/span> -f 2&lt;span style="color:#ff79c6">)&lt;/span> 2&amp;gt;/dev/null
&lt;span style="color:#8be9fd;font-style:italic">NAME&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>dbus-send --print-reply --dest&lt;span style="color:#ff79c6">=&lt;/span>org.mpris.MediaPlayer2.ElectronNCM /org/mpris/MediaPlayer2 org.freedesktop.DBus.Properties.Get string:org.mpris.MediaPlayer2.Player string:Metadata | sed -n &lt;span style="color:#f1fa8c">&amp;#39;/title/{n;p}&amp;#39;&lt;/span> | cut -d &lt;span style="color:#f1fa8c">&amp;#39;&amp;#34;&amp;#39;&lt;/span> -f 2&lt;span style="color:#ff79c6">)&lt;/span> 2&amp;gt;/dev/null
&lt;span style="color:#6272a4"># 其中 dest 参数为我的音乐播放器的名称，这是我翻源代码翻出来的。&lt;/span>
&lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$NAME&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">]&lt;/span>
&lt;span style="color:#ff79c6">then&lt;/span>
&lt;span style="color:#8be9fd;font-style:italic">CONTENT&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$NOSONG&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;span style="color:#ff79c6">else&lt;/span>
&lt;span style="color:#8be9fd;font-style:italic">CONTENT&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$PREFIX&lt;/span>&lt;span style="color:#f1fa8c"> &lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$NAME&lt;/span>&lt;span style="color:#f1fa8c"> - &lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$ARTIST&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;span style="color:#ff79c6">fi&lt;/span>
&lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$CONTENT&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>cat &lt;span style="color:#8be9fd;font-style:italic">$FILENAME&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">]&lt;/span>
&lt;span style="color:#ff79c6">then&lt;/span>
sleep 1;
&lt;span style="color:#ff79c6">else&lt;/span>
&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$CONTENT&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> &amp;gt; &lt;span style="color:#8be9fd;font-style:italic">$FILENAME&lt;/span>
&lt;span style="color:#ff79c6">fi&lt;/span>
&lt;span style="color:#ff79c6">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>OBS Studio 怎么设置显示文件内容，我就不在此赘述了。&lt;/p>
&lt;h1 id="后记">后记&lt;/h1>
&lt;p>不禁感叹一句，Linux 下获取正在播放的媒体可比 macOS 简单多了。&lt;/p>
&lt;p>其实这篇文章应该是很早就写完的（脚本是2019年10月1号写完的）。但是由于本人工作繁忙，加上事情特别多，根本顾不上水这篇博文。&lt;/p>
&lt;p>当时水了一些别的文章，总之这篇文章就留到了今年。&lt;/p>
&lt;p>希望对各位有所帮助。&lt;/p>
&lt;p>&lt;del>又水完一篇博客，好开心。&lt;/del>&lt;/p>
- https://risehere.net/posts/obs-now-playing/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>如何优雅地使用 Spyder 的调试器</title><link>https://risehere.net/2019/10/28/howto-use-spyder-debugger/</link><pubDate>Mon, 28 Oct 2019 23:28:09 +0000</pubDate><guid>https://risehere.net/2019/10/28/howto-use-spyder-debugger/</guid><description>左手的世界 https://risehere.net/2019/10/28/howto-use-spyder-debugger/ -&lt;h1 id="前言">前言&lt;/h1>
&lt;p>这是一个面向初学者的文章.
很多朋友在初学编程的时候很难找出错误,或者对程序运行流程不太清楚.
这个时候调试器就要上场了~
所以在这里我要以Spyder为例,介绍调试器的用法.&lt;/p>
&lt;h2 id="为什么">为什么&lt;/h2>
&lt;h3 id="我们为什么要学会调试">我们为什么要学会调试&lt;/h3>
&lt;p>学会调试,对于我们理解程序的运行流程,以及找bug很有帮助.
想一下,如果我们能够在程序运行的时候,实时查看变量是怎么变化,岂不美哉?&lt;/p>
&lt;h3 id="为嘛要用spyder">为嘛要用Spyder&lt;/h3>
&lt;p>首先,这是一个面向Python初学者的文章.
考虑到本篇文章的读者可能都是从Anaconda开始的,所以我在此以Spyder为例讲解调试器的使用.
其他IDE的调试功能其实大同小异.&lt;/p>
&lt;hr />
&lt;h1 id="spyder初体验">Spyder初体验&lt;/h1>
&lt;h2 id="熟悉spyder的界面">熟悉Spyder的界面&lt;/h2>
&lt;p>我们先来熟悉一下Spyder的界面.
&lt;img src="spyder-main.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>最上面有一排按钮,我们俗称工具栏.&lt;/li>
&lt;li>在左侧,我们可以写代码. 按一下工具栏上&lt;strong>绿色&lt;/strong>的开始按钮,即可开始运行程序.&lt;/li>
&lt;li>右侧分为上下两栏.
&lt;ul>
&lt;li>上栏中,有三个&lt;code>选项卡&lt;/code>.分别是&lt;code>Variable explorer&lt;/code>(这个很重要),&lt;code>File explorer&lt;/code>,还有&lt;code>Help&lt;/code>(后面两个基本没啥鸟用)&lt;/li>
&lt;li>下栏叫做&lt;code>IPython console&lt;/code>,我们俗称为&lt;strong>控制台&lt;/strong>. 一般来说,运行代码时候的输出,会在控制台里面看到. 当然,我们可以在没有运行代码的时候,在&lt;code>In [n]: &lt;/code>(n是几不用关心)后面打入命令与控制台交互.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="用spyder运行示例代码">用Spyder运行示例代码&lt;/h2>
&lt;p>现在我们在左侧代码区域,粘贴下面的代码.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Python" data-lang="Python">a &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>
&lt;span style="color:#ff79c6">for&lt;/span> i &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">range&lt;/span>(&lt;span style="color:#bd93f9">10&lt;/span>):
i &lt;span style="color:#ff79c6">+=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
a &lt;span style="color:#ff79c6">+=&lt;/span> i
&lt;span style="color:#ff79c6">print&lt;/span>(a)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后按一下绿色的开始按钮,我们可以在&lt;strong>控制台&lt;/strong>中看到输出.
输出:&lt;/p>
&lt;pre>&lt;code>55
&lt;/code>&lt;/pre>&lt;p>&lt;em>给初学者的注释: i += 1 等同于 i = i + 1.&lt;/em>&lt;/p>
&lt;h2 id="调试目标">调试目标&lt;/h2>
&lt;p>我们想知道每一次for循环进行的时候,a和 i的值是怎么变化的.&lt;/p>
&lt;h1 id="朴素的-print-调试法">朴素的 print 调试法&lt;/h1>
&lt;p>这个方法自古以来就有了. &lt;del>(胡说,古代哪有Python)&lt;/del>
在没有调试器的漫漫长夜中,这种直接输出到屏幕上的调试方法最为实用.&lt;/p>
&lt;p>既然我们想要看a和i在每一次for循环中的值是多少,那么我们直接print出来就好了!
所以我们把代码修改成:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Python" data-lang="Python">a &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>
&lt;span style="color:#ff79c6">for&lt;/span> i &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">range&lt;/span>(&lt;span style="color:#bd93f9">10&lt;/span>):
i &lt;span style="color:#ff79c6">+=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;span style="color:#ff79c6">print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;此时i的值为:&amp;#34;&lt;/span>,i) &lt;span style="color:#6272a4"># 在i变化后立马print,看看它的值是多少&lt;/span>
a &lt;span style="color:#ff79c6">+=&lt;/span> i
&lt;span style="color:#ff79c6">print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;此时a的值为:&amp;#34;&lt;/span>,a) &lt;span style="color:#6272a4"># 在a变化后立马print,看看它的值是多少&lt;/span>
&lt;span style="color:#ff79c6">print&lt;/span>(a)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行结果是这样的:&lt;/p>
&lt;pre>&lt;code>此时i的值为: 1
此时a的值为: 1
中间省略无数个此时
此时i的值为: 10
此时a的值为: 55
55
&lt;/code>&lt;/pre>&lt;p>这样我们就能看出来每次for循环的i和a的变化情况了.&lt;/p>
&lt;p>但是这样太麻烦了,而且满屏幕的i的值,a的值,看得人眼晕.
而且当变量很多的时候,我们要加很多print.
最后到了提交之前,还要记得把自己打的这些print给删除掉.&lt;/p>
&lt;p>那么,有没有更直观,更优雅的方法呢?&lt;/p>
&lt;h1 id="隆重登场的调试器法">隆重登场的调试器法&lt;/h1>
&lt;p>我们如果要运行程序,只需要点击工具栏中那个绿色的开始按钮就可以了.&lt;/p>
&lt;p>但是这只是&lt;strong>单纯的运行&lt;/strong>.
它会像IDLE一样,正常运行程序,没有调试没有逗留.&lt;/p>
&lt;h2 id="第一招式---逐行调试">第一招式 - 逐行调试&lt;/h2>
&lt;h3 id="进入调试模式">进入调试模式&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>想要开始调试,我们需要按下图中所示的&lt;strong>1号按钮&lt;/strong>(Debug File).
&lt;img src="spyder-debug.png" alt="" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后我们再&lt;strong>点击一下&lt;/strong>下图中红色箭头所指的&lt;code>Variable explorer&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>红色箭头: 一定要记住,我们一定要&lt;strong>切换&lt;/strong>到下图中红色箭头所指的&lt;code>Variable explorer&lt;/code>,这样我们才可以看到变量此时的值. (不过因为我们还没有执行第一行代码,所以这里是空的.)
&lt;img src="start-debug-1.png" alt="" />&lt;/li>
&lt;li>蓝色箭头: 它所指的地方,上面有个&lt;code>----&amp;gt;&lt;/code>的符号,并且后面有&lt;strong>行号&lt;/strong>1.这代表当前调试器&lt;strong>将要&lt;/strong>(还未)运行第一行代码. &lt;em>(划重点,不要搞错,「将要」)&lt;/em>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr />
&lt;h3 id="开始逐行调试">开始逐行调试&lt;/h3>
&lt;p>现在,按下图中所示的2号按钮**(以下称为Run Current Line)**,开始在调试器里面运行下一行代码.
&lt;img src="spyder-debug.png" alt="" />&lt;/p>
&lt;p>我们可以看到,&lt;code>Variable explorer&lt;/code>里面多出了变量&lt;code>a&lt;/code>.
其中&lt;code>Name&lt;/code>代表这个变量的&lt;strong>名称&lt;/strong>,第二栏&lt;code>Type&lt;/code>是这个变量的&lt;strong>类型&lt;/strong>.而最后一栏&lt;code>Value&lt;/code>是该变量的&lt;strong>值&lt;/strong>.(Size不用管,暂时用不上.)
并且控制台中的&lt;code>----&amp;gt;&lt;/code>符号指向了第二行. 说明第一行执行完毕,再次点击将执行第二行.
&lt;img src="start-debug-2.png" alt="" />&lt;/p>
&lt;p>举个例子:
以图中的变量&lt;code>a&lt;/code>为例,这个变量的名称是&lt;code>a&lt;/code>,它的类型是&lt;code>int&lt;/code>,值为&lt;code>0&lt;/code>.
(正好也和我们预期的情况相同&amp;ndash;我们执行了一句&lt;code>a=0&lt;/code>)&lt;/p>
&lt;hr />
&lt;p>我们接着点刚才的&lt;strong>Run Current Line&lt;/strong>.可以看到,&lt;code>Variable explorer&lt;/code>中又多出了第二行变量&lt;code>i&lt;/code>.并且此时控制台中的&lt;code>----&amp;gt;&lt;/code>指向了第三行.
&lt;img src="start-debug-3.png" alt="" />
这说明此时,&lt;code>i&lt;/code>的值为&lt;code>0&lt;/code>,&lt;code>a&lt;/code>的值也为&lt;code>0&lt;/code>.&lt;/p>
&lt;hr />
&lt;p>我们点击&lt;strong>Run Current Line&lt;/strong>(这是第三次).发现&lt;code>i&lt;/code>的值由&lt;code>0&lt;/code>变为&lt;code>1&lt;/code>.
再点击一次&lt;strong>Run Current Line&lt;/strong>(这是第四次),&lt;code>a&lt;/code>的值也变成了&lt;code>1&lt;/code>.
注意一下,经过四次逐行执行,控制台输出如下:&lt;/p>
&lt;pre>&lt;code>ipdb&amp;gt; None
&amp;gt; c:\users\rise\desktop\temp.py(2)&amp;lt;module&amp;gt;()
1 a = 0
----&amp;gt; 2 for i in range(10):
3 i += 1
4 a += i
5 print(a)
&lt;/code>&lt;/pre>&lt;p>我们可以看到,&lt;code>----&amp;gt;&lt;/code>符号指向第二行(for所在的那行).
这说明此时第一次for循环执行完毕.由于还有&lt;strong>后面的循环&lt;/strong>,所以这里程序要&lt;strong>跳回for循环的起始位置&lt;/strong>,继续进行剩下几次循环.&lt;/p>
&lt;hr />
&lt;p>我们通过逐行调试,可以很直观清楚地跟踪程序的运行过程.
如果我们想中途停止此次调试,只需要点击一下&lt;strong>6号按钮&lt;/strong>,即&lt;code>Stop Debugging&lt;/code>.
&lt;img src="spyder-debug.png" alt="" />&lt;/p>
&lt;p>这就是逐行调试了.&lt;/p>
&lt;hr />
&lt;h3 id="小总结">小总结&lt;/h3>
&lt;p>来总结一下:&lt;/p>
&lt;ol>
&lt;li>要开始调试,需要点击&lt;code>Debug File&lt;/code>. 点击之后,会进入调试模式.&lt;/li>
&lt;li>一定记得切换到&lt;code>Variable explorer&lt;/code>,这样才能查看变量的变化情况.&lt;/li>
&lt;li>点击&lt;code>Run Current Line&lt;/code>,运行第一行代码.&lt;/li>
&lt;li>继续点击&lt;code>Run Current Line&lt;/code>这个按钮,会&lt;strong>按照程序逻辑&lt;/strong>运行下一行代码. 直至执行完毕为止.&lt;/li>
&lt;li>通过点击&lt;code>Stop Debugging&lt;/code>,我们可以停止调试.&lt;/li>
&lt;/ol>
&lt;p>在上述的调试过程中:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Variable explorer&lt;/code>中将显示当前存在的所有变量. &lt;code>Type&lt;/code>表示该变量的类型&lt;code>Value&lt;/code>一栏将显示变量的值.(不要看走眼,不是&lt;code>Size&lt;/code>一栏)&lt;/li>
&lt;li>在控制台中,我们可以通过&lt;code>----&amp;gt;&lt;/code>这个符号所指向的行数,看到即将被执行的代码是哪一行.&lt;/li>
&lt;/ul>
&lt;hr />
&lt;h2 id="第二招式---断点调试">第二招式 - 断点调试&lt;/h2>
&lt;p>断点调试顾名思义,是可以在某一行(或多行)设置断点,对该行进行调试.
而逐行调试是对每一行进行调试.
断点调试是更有针对性的调试方法.&lt;/p>
&lt;p>如果你能搞清楚逐行调试,那么断点调试也不难.&lt;/p>
&lt;h3 id="设置断点">设置断点&lt;/h3>
&lt;p>如图. 双击某一行行号前面的空白处,之后在这个地方会出现如图所示的小红点.
&lt;img src="set-breakpoint.png" alt="" />
这个小红点就是我们所说的断点.&lt;/p>
&lt;h3 id="开始调试">开始调试&lt;/h3>
&lt;p>如图所示,我们现在在&lt;strong>第3行,第4行&lt;/strong>设置&lt;strong>两个&lt;/strong>断点.&lt;/p>
&lt;p>我们按&lt;code>Debug File&lt;/code>开始调试代码.
此时可以看到,控制台里面的显示是这样的:&lt;/p>
&lt;pre>&lt;code>ipdb&amp;gt; &amp;gt; c:\users\rise\desktop\temp.py(3)&amp;lt;module&amp;gt;()
1 a = 0
2 for i in range(10):
1---&amp;gt; 3 i += 1
2 4 a += i
5 print(a)
&lt;/code>&lt;/pre>&lt;p>其中,行号前面的1和2,代表我们设置的两个断点.
所以此时即将运行&lt;strong>第一个断点处,即第三行.&lt;/strong>&lt;/p>
&lt;h3 id="继续调试">继续调试&lt;/h3>
&lt;p>程序的执行此时暂停.我们要让它继续运行,需要按一下第五个按钮,即&lt;code>Continue executation until next breakpoint&lt;/code>:
&lt;img src="spyder-debug.png" alt="" />
这个按钮的意思就是,继续执行直到下一个断点.
因为我们第二个断点设置在第四行,所以代码将继续执行,在&lt;strong>将要执行&lt;/strong>第四行的时候会暂停.&lt;/p>
&lt;h3 id="断点调试小总结">断点调试小总结&lt;/h3>
&lt;p>我来总结一下断点调试的几个步骤.&lt;/p>
&lt;ol>
&lt;li>双击行号前面的空白处,以设置断点&lt;/li>
&lt;li>点击&lt;code>Debug file&lt;/code>开始进入调试&lt;/li>
&lt;li>在调试过程中,通过&lt;code>Variable explorer&lt;/code>观察变量的值&lt;/li>
&lt;li>点击&lt;code>Continue executation until next breakpoint&lt;/code>执行到下一个断点处.&lt;/li>
&lt;li>通过点击&lt;code>Stop Debugging&lt;/code>,我们可以停止调试.&lt;/li>
&lt;/ol>
&lt;hr />
&lt;h2 id="调试器总结">调试器总结&lt;/h2>
&lt;p>几点需要注意的地方:&lt;/p>
&lt;ul>
&lt;li>每次打开Spyder的时候,右上方区域默认显示的是&lt;code>Help&lt;/code>. 所以我们需要手动切换到&lt;code>Variable explorer&lt;/code>.&lt;/li>
&lt;li>在调试的时候,&lt;code>----&amp;gt;&lt;/code>指向的是即将执行的代码,而&lt;strong>不是已经执行的代码&lt;/strong>.&lt;/li>
&lt;li>当一次调试完毕后,开始第二次调试的时候,&lt;code>Variable explorer&lt;/code>&lt;strong>不会&lt;/strong>自己清空. 这点一定要注意,上一次调试残留的变量的值仍然会留在&lt;code>Variable explorer&lt;/code>里面. 所以我们可以按一下下图所示的按钮清空.
&lt;img src="clear-explorer.png" alt="" />&lt;/li>
&lt;/ul>
&lt;hr />
&lt;h1 id="写在最后">写在最后&lt;/h1>
&lt;p>调试是IDE中很重要的一个功能.
这篇文章虽然字很多,但实际上用起来是很简单的,它并不复杂,而且很适合新手.
如果我们学会了调试器的使用,那么写代码将会事半功倍.&lt;/p>
&lt;p>另外,其他的IDE的调试功能也是大同小异.大家可以探索一下!&lt;/p>
&lt;p>那么最后呢,就祝各位学有所成~ Cheers!&lt;/p>
&lt;p>(未完待续,因为可能会有补充)&lt;/p>- https://risehere.net/2019/10/28/howto-use-spyder-debugger/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>我的一份自我介绍</title><link>https://risehere.net/about/</link><pubDate>Fri, 25 Oct 2019 23:46:42 +0000</pubDate><guid>https://risehere.net/about/</guid><description>左手的世界 https://risehere.net/about/ -&lt;h1 id="前言">前言&lt;/h1>
&lt;p>我的 GitHub 链接: &lt;a href="https://github.com/amazingrise">AmazingRise&lt;/a>&lt;/p>
&lt;p>此页正在建设中^_^&lt;/p>
&lt;p>（正是因为上面这句话，博客从腾讯云迁移到了 Github，具体原因不方便说）&lt;/p>
&lt;h1 id="关于本站">关于本站&lt;/h1>
&lt;h2 id="版权声明">版权声明&lt;/h2>
&lt;p>本站遵循 &lt;a href="https://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC 4.0 协议&lt;/a>.&lt;/p>
&lt;h1 id="关于我">关于我&lt;/h1>
&lt;p>我叫 Rise.&lt;/p>
&lt;h2 id="创作">创作&lt;/h2>
&lt;p>创作是一件美好的事情。&lt;/p>
&lt;p>我喜欢创作。&lt;/p>
&lt;p>因为创作可以给大家带来欢乐。&lt;/p>
&lt;p>写代码也是一种创作。&lt;/p>
&lt;p>我的代码可能会帮助到世界上的其他人&lt;/p>
&lt;p>我乐此不疲&lt;/p>
&lt;p>😉️&lt;/p>
&lt;h2 id="音乐">音乐&lt;/h2>
&lt;p>虽然没有创作音乐的才能&amp;hellip; 🙈️&lt;/p>
&lt;p>但是我很喜欢听音乐。&lt;/p>
&lt;p>尤其是一些老摇滚。&lt;/p>
&lt;p>像是甲壳虫，枪花，绿洲&amp;hellip;&lt;/p>
&lt;h2 id="运动">运动&lt;/h2>
&lt;p>我喜欢骑单车，能骑到好远的地方。&lt;/p>
&lt;p>还有什么呢。&lt;/p>
&lt;h1 id="未完待续">未完待续&lt;/h1>
&lt;p>剩下的，留着我有时间补充吧。&lt;/p>
- https://risehere.net/about/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>(译)Kotlin中的等号，"=="，"==="和"equals"</title><link>https://risehere.net/2019/05/18/equality-in-kotlin-translation/</link><pubDate>Sat, 18 May 2019 10:47:06 +0000</pubDate><guid>https://risehere.net/2019/05/18/equality-in-kotlin-translation/</guid><description>左手的世界 https://risehere.net/2019/05/18/equality-in-kotlin-translation/ -&lt;p>Translated from: &lt;a href="https://medium.com/@agrawalsuneet/equality-in-kotlin-and-equals-d8373ef529f1">Equality in Kotlin&lt;/a>
Author: Suneet Agrawal
Translated by : AmazingRise (Authorized by original author)&lt;/p>
&lt;p>在编程中，我们经常需要比较两个变量的值是否相等，或者两个对象的引用是否一致。
Kotlin语言里，“等号”有这么几种：&lt;code>==&lt;/code>，&lt;code>===&lt;/code>与&lt;code>.equals&lt;/code>。
那么问题来了，我们该如何正确使用这些相等性判断呢？&lt;/p>
&lt;!-- more -->
&lt;p>我们来一起看一看Kotlin的几种相等性判断：&lt;/p>
&lt;h2 id="结构性相等--">结构性相等 (&amp;ldquo;==&amp;rdquo;)&lt;/h2>
&lt;p>&lt;code>==&lt;/code>操作符用于比较两个变量的值。
&lt;strong>请不要与Java中的&lt;code>==&lt;/code>相混淆。&lt;/strong>
与Java中的&lt;code>==&lt;/code>操作符&lt;strong>不同&lt;/strong>的是：&lt;code>==&lt;/code>操作符在Kotlin中只比较值。
而Java或其它语言中，&lt;code>==&lt;/code>通常用来比较两个对象的引用。
Kotlin中，&lt;code>==&lt;/code>的否定形式是&lt;code>!=&lt;/code>，当两个变量值不同时返回真。&lt;/p>
&lt;h2 id="引用性相等-">引用性相等(&amp;ldquo;===&amp;rdquo;)&lt;/h2>
&lt;p>&lt;code>===&lt;/code>操作符用于比较两个变量的引用是否一致。只有当两个变量指向同一个实例时，&lt;code>===&lt;/code>的值才为真。
&lt;code>===&lt;/code>的否定形式是&lt;code>!==&lt;/code>，当两个对象的引用不同的时候返回真。&lt;/p>
&lt;p>不过对于原始类型（Primitive type）来说（例如 Int），&lt;code>=== &lt;/code>等价于&lt;code> ==&lt;/code> 。&lt;/p>
&lt;h2 id="equals-方法-">.equals 方法&lt;/h2>
&lt;p>&lt;code>equals(other: Any?)&lt;/code>方法是在&lt;code>Any&lt;/code>类里实现的。
并且所有类中&lt;code>.equals&lt;/code>都可以被重写（毕竟所有的类都继承于Any嘛，就像Java里的Object一样）。&lt;/p>
&lt;p>&lt;code>.equals&lt;/code>方法将会比较两个变量的值。
与&lt;code>==&lt;/code>不同体现在比较&lt;code>Float&lt;/code>和&lt;code>Double&lt;/code>的时候，&lt;code>.equals&lt;/code>违背了IEEE 754 浮点数运算标准。&lt;/p>
&lt;p>&lt;strong>与IEEE 754浮点数运算标准相违背，意味着什么？&lt;/strong>&lt;/p>
&lt;p>这意味着：&lt;/p>
&lt;ul>
&lt;li>NaN 等于它本身&lt;/li>
&lt;li>NaN 比任何其他元素要大，包括正无穷 &lt;code>POSITIVE_INFINITY&lt;/code>&lt;/li>
&lt;li>编译器会认为&lt;code>-0.0&lt;/code> 要比 &lt;code>0.0&lt;/code> 小。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>一头雾水？&lt;/strong>&lt;/p>
&lt;h2 id="举个栗子-">举个栗子&lt;/h2>
&lt;p>我来举几个例子解释一下。&lt;/p>
&lt;p>首先，我们用这几个方法比较两个原始类型的变量（Int）。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Kotlin" data-lang="Kotlin"> &lt;span style="color:#ff79c6">val&lt;/span> int1 = &lt;span style="color:#bd93f9">10&lt;/span>
&lt;span style="color:#ff79c6">val&lt;/span> int2 = &lt;span style="color:#bd93f9">10&lt;/span>
println(int1 == int2) &lt;span style="color:#6272a4">// true
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> println(int1.equals(int2)) &lt;span style="color:#6272a4">// true
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> println(int1 === int2) &lt;span style="color:#6272a4">// true
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这三个println最后都会输出&lt;code>true&lt;/code>，因为对于原始类型，这三种判断都仅仅检查变量的值。
所以在这种情况下，&lt;code>===&lt;/code>输出的结果也是一样的。&lt;/p>
&lt;p>现在让我们把原始类型换成包装类，看看三种方法表现出的行为。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Kotlin" data-lang="Kotlin"> &lt;span style="color:#ff79c6">val&lt;/span> first = Integer(&lt;span style="color:#bd93f9">10&lt;/span>)
&lt;span style="color:#ff79c6">val&lt;/span> second = Integer(&lt;span style="color:#bd93f9">10&lt;/span>)
println(first == second) &lt;span style="color:#6272a4">//true
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> println(first.equals(second)) &lt;span style="color:#6272a4">//true
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> println(first === second) &lt;span style="color:#6272a4">//false
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上面的例子中，&lt;code>==&lt;/code>与&lt;code>.equals&lt;/code>输出了&lt;code>true&lt;/code>，因为他们仅仅比较了两个变量的值。
而&lt;code>===&lt;/code>比较了对象的引用，而这两个对象的引用是不同的，所以最后输出了&lt;code>false&lt;/code>。&lt;/p>
&lt;p>现在我们来看另一种情况。我们自己定义一个类，然后再用这三个方法：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Kotlin" data-lang="Kotlin">&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Employee&lt;/span> (&lt;span style="color:#ff79c6">val&lt;/span> name: String)
&lt;span style="color:#ff79c6">val&lt;/span> emp1 = Employee(“Suneet”)
&lt;span style="color:#ff79c6">val&lt;/span> emp2 = Employee(“Suneet”)
println(emp1 == emp2) &lt;span style="color:#6272a4">//false
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> println(emp1.equals(emp2)) &lt;span style="color:#6272a4">//false
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> println(emp1 === emp2) &lt;span style="color:#6272a4">//false
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>
println(emp1.name == emp2.name) &lt;span style="color:#6272a4">//true
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> println(emp1.name.equals(emp2.name)) &lt;span style="color:#6272a4">//true
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> println(emp1.name === emp2.name) &lt;span style="color:#6272a4">//true
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果显而易见。因为Employee类既不是原始数据类型，也不是包装类，这种情况下它们都会比较两个变量的引用，所以它们都返回了&lt;code>false&lt;/code>。
但是对于字符串的比较，这三个方法都只检查了字符串的内容，所以它们都返回了&lt;code>true&lt;/code>。&lt;/p>
&lt;p>&lt;strong>等等，你说&lt;code>==&lt;/code>和&lt;code>.equals&lt;/code>只比较两个对象的内容，在我们的这个例子里它们都是一样的呀&lt;/strong>
(译者注：指第一段，三个比较全都返回了false)
**这没毛病。**但内容比较仅对于&lt;code>data&lt;/code>类起作用。对于普通的类，即使两个对象内容完全一致，编译器也会认为两个对象是不同的。而对于&lt;code>data&lt;/code>类，编译器将比较对象的内容，并且在内容相同的情况下返回&lt;code>true&lt;/code>。&lt;/p>
&lt;p>让我们把上面的普通类改为&lt;code>data&lt;/code>类：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Kotlin" data-lang="Kotlin">&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Employee&lt;/span> (&lt;span style="color:#ff79c6">val&lt;/span> name: String)
&lt;span style="color:#ff79c6">val&lt;/span> emp1 = Employee(&lt;span style="color:#f1fa8c">&amp;#34;Suneet&amp;#34;&lt;/span>)
&lt;span style="color:#ff79c6">val&lt;/span> emp2 = Employee(&lt;span style="color:#f1fa8c">&amp;#34;Suneet&amp;#34;&lt;/span>)
println(emp1 == emp2) &lt;span style="color:#6272a4">//true
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> println(emp1.equals(emp2)) &lt;span style="color:#6272a4">//true
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> println(emp1 === emp2) &lt;span style="color:#6272a4">//false
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>
println(emp1.name == emp2.name) &lt;span style="color:#6272a4">//true
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> println(emp1.name.equals(emp2.name)) &lt;span style="color:#6272a4">//true
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> println(emp1.name === emp2.name) &lt;span style="color:#6272a4">//true
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这回就没问题了。最后我们看一下浮点数的比较，我们来看看“正数0”和“负数0”：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Kotlin" data-lang="Kotlin">&lt;span style="color:#ff79c6">val&lt;/span> negZero = -&lt;span style="color:#bd93f9">0.0f&lt;/span>
&lt;span style="color:#ff79c6">val&lt;/span> posZero = &lt;span style="color:#bd93f9">0.0f&lt;/span>
println(negZero == posZero) &lt;span style="color:#6272a4">//true
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>println(negZero.equals(posZero)) &lt;span style="color:#6272a4">//false
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>println(negZero === posZero) &lt;span style="color:#6272a4">//true
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于&lt;code>Float&lt;/code>和&lt;code>Double&lt;/code>类的比较，&lt;code>.equals&lt;/code>方法违背了IEEE 754 浮点数运算标准，当&lt;code>-0.0&lt;/code>与&lt;code>0.0&lt;/code>比较的时候，它会返回&lt;code>false&lt;/code>。
而&lt;code>==&lt;/code>和&lt;code>===&lt;/code>都会返回&lt;code>true&lt;/code>。&lt;/p>
&lt;h2 id="最后谨记-">最后谨记&lt;/h2>
&lt;ul>
&lt;li>因为Kotlin里没有像&lt;code>String(&amp;quot;&amp;quot;)&lt;/code>这样的构造器，当比较字符串的时候，只要内容相等，都会返回&lt;code>true&lt;/code>。&lt;/li>
&lt;li>对于&lt;code>null&lt;/code>引用的判断，我们不必做任何优化。&lt;code>a == null&lt;/code> 会被自动转换为 &lt;code>a === null&lt;/code>，因为null本身也是一个引用，它将会引发引用检查（而不是值检查）。&lt;/li>
&lt;/ul>
&lt;p>就酱。&lt;a href="https://agrawalsuneet.github.io/agrawalsuneet/publications/">点击这里&lt;/a>看看我写的其他有趣文章。
或者&lt;a href="https://agrawalsuneet.github.io/agrawalsuneet/personalgamesandapps/">点击这里&lt;/a>，瞧一瞧我写的App和游戏。
另外，欢迎在你的App里面使用&lt;a href="https://agrawalsuneet.github.io/agrawalsuneet/opensourcecontribution/">我的Android开源组件&lt;/a>。
如果你需要帮助的话，可以给我发邮件： agrawalsuneet AT gmail.com。&lt;/p>
&lt;p>引用: &lt;a href="https://kotlinlang.org/docs/reference/equality.html">Kotlin docs&lt;/a>&lt;/p>
&lt;hr />
&lt;p>翻译完结。&lt;/p>
&lt;p>作者：Suneet Agrawal.
网站：https://agrawalsuneet.github.io/agrawalsuneet/
十分感谢作者写的文章，以及授权本人翻译，以分享给中国开发者。
原作者保留所有权利。&lt;/p>
- https://risehere.net/2019/05/18/equality-in-kotlin-translation/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>Manjaro 在笔记本上的多显示器配置</title><link>https://risehere.net/posts/manjaro-optimus-dual-monitor/</link><pubDate>Sat, 20 Apr 2019 16:11:20 +0000</pubDate><guid>https://risehere.net/posts/manjaro-optimus-dual-monitor/</guid><description>左手的世界 https://risehere.net/posts/manjaro-optimus-dual-monitor/ -&lt;h1 id="最新方法">最新方法&lt;/h1>
&lt;p>2020.9.12 更新&lt;/p>
&lt;p>这篇文章里提到的解决方法应该&lt;strong>用不上了&lt;/strong>，因为 &lt;code>video-hybrid-intel-nvidia-450xx-prime&lt;/code> 可以&lt;strong>直接识别&lt;/strong>笔记本上的双显示器。&lt;/p>
&lt;ul>
&lt;li>如果你以前没看过这篇教程，并且双显示器不能正常工作，建议在系统设置里将驱动更换为 &lt;code>video-hybrid-intel-nvidia-450xx-prime&lt;/code>，在&lt;strong>更换完成前不要看这篇文章&lt;/strong>。&lt;/li>
&lt;li>如果你以前看过这篇教程，建议将现有的&lt;code>video-nvidia-???xx&lt;/code>更换为上述驱动，并且记得把这篇教程里更改过的配置文件&lt;strong>一一还原&lt;/strong>。这个新的驱动修复了很多小问题。&lt;/li>
&lt;li>如果你用的就是 &lt;code>video-hybrid-intel-nvidia-450xx-prime&lt;/code>，并且双显示器无法工作，那么你可以参考这篇文章的内容，&lt;strong>也许&lt;/strong>对你有帮助。&lt;/li>
&lt;/ul>
&lt;hr />
&lt;p>重要的话说三遍：&lt;/p>
&lt;p>建议将驱动更换为 &lt;code>video-hybrid-intel-nvidia-450xx-prime&lt;/code>，在&lt;strong>更换完成前不要看这篇文章&lt;/strong>。&lt;/p>
&lt;p>建议将驱动更换为 &lt;code>video-hybrid-intel-nvidia-450xx-prime&lt;/code>，在&lt;strong>更换完成前不要看这篇文章&lt;/strong>。&lt;/p>
&lt;p>建议将驱动更换为 &lt;code>video-hybrid-intel-nvidia-450xx-prime&lt;/code>，在&lt;strong>更换完成前不要看这篇文章&lt;/strong>。&lt;/p>
&lt;p>失败了再回来试一下这篇文章的方法。&lt;/p>
&lt;hr />
&lt;h1 id="背景">背景&lt;/h1>
&lt;p>解决方法请翻到&lt;a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-">解决方法&lt;/a>一节。&lt;/p>
&lt;p>环境：&lt;/p>
&lt;p>intel 集成显卡 + Nvidia 独立显卡，目前笔记本主流配置。但 HDMI 接口实际上是与 Nvidia 显卡相连接的，默认驱动无法对 N 卡输出。&lt;/p>
&lt;p>症状：&lt;/p>
&lt;ul>
&lt;li>无法接外接显示器，接上后无论是系统设置还是&lt;code>inxi -Fx&lt;/code>都无法识别外置显示器。&lt;/li>
&lt;li>检查启动日志，发现虽然开机时检测到了显示器，但后面就没有继续显示了。&lt;/li>
&lt;/ul>
&lt;p>如果你的是&lt;strong>外接显卡坞+显示器，这篇教程不适合你&lt;/strong>。不过有网友（感谢&lt;code>@sunlitforest&lt;/code>）用另一种方法操作成功了，详情请看&lt;a href="https://github.com/AmazingRise/amazingrise.github.io/issues/11#issuecomment-613202749">这里&lt;/a>。&lt;/p>
&lt;p>参照&lt;a href="https://wiki.archlinux.org/index.php/NVIDIA_Optimus_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">ArchWiki上面的说法&lt;/a>，让Optimus显卡在linux里面有三种实现方法：&lt;/p>
&lt;ol>
&lt;li>BIOS里面禁用掉一个显卡。缺点：难以切换显卡。&lt;/li>
&lt;li>用nouveau的PRIME功能。但是性能没有专有驱动好，睡眠和挂起也会出现问题。&lt;/li>
&lt;li>用Bumblebee。不过Bumblebee很难支持双显示器。&lt;/li>
&lt;li>用专有驱动。&lt;/li>
&lt;li>用nvidia-xrun，让X服务器跑在n卡上。（貌似和1一样，但是1是硬件层面上的禁用。）&lt;/li>
&lt;/ol>
&lt;hr />
&lt;h1 id="解决方法">解决方法&lt;/h1>
&lt;p>我找到了Manjaro论坛里面的一个帖子。（作者Jonathon，是Manjaro开发团队的）&lt;/p>
&lt;p>刚开始没有成功，后来在朋友的提醒下，发现原来我缺了一些步骤！
我照着这个帖子的步骤原封不动地操作，成功了。所以，接下来一定要按照步骤严格操作。&lt;/p>
&lt;p>以下内容均为本人的中文翻译。&lt;a href="https://archived.forum.manjaro.org/t/howto-set-up-prime-output-offload-with-nvidia-proprietary-driver/40225">原帖在此 - How To Set up PRIME with NVIDIA proprietary driver&lt;/a>&lt;/p>
&lt;p>如何在Optimus的笔记本上开启PRIME：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th align="left">方法&lt;/th>
&lt;th align="left">优点&lt;/th>
&lt;th align="left">缺点&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td align="left">bumblebee(Render offload)&lt;/td>
&lt;td align="left">按需使用独立显卡，Manjaro默认配置&lt;/td>
&lt;td align="left">有一定的开销，对性能有所影响&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">PRIME&lt;/td>
&lt;td align="left">直接使用独立显卡，性能更强&lt;/td>
&lt;td align="left">两块显卡都一直供电，需要手动配置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">optimus-manager&lt;/td>
&lt;td align="left">显卡切换更简单&lt;/td>
&lt;td align="left">暂不成熟，还在开发中&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">video-hybrid-intel-nvidia-440xx-prime&lt;/td>
&lt;td align="left">NVIDIA 官方支持的 render offload.&lt;/td>
&lt;td align="left">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>Note:最简单的方法就是在主板设置里面禁用集成显卡，如果可以就直接禁用掉。&lt;br />
optimus-manager可以实现两块显卡的半自动切换，但是目前仍然不太成熟。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>免责声明：NVIDIA Optimus在Linux下目前一团糟，硬件设置千差万别。所以这个教程可能有不适用之处，建议参考ArchWiki获取更多信息。&lt;/p>
&lt;/blockquote>
&lt;h2 id="1-移除bumblebee">1 移除Bumblebee&lt;/h2>
&lt;p>如果你选择了non-free驱动，mhwd将会自动安装bumblebee。
bumblebee很碍事，所以我们得先干掉它。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">sudo mhwd -r pci nonfree &lt;span style="color:#bd93f9">0300&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2-安装nvidia驱动">2 安装NVIDIA驱动&lt;/h2>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">sudo mhwd -i pci video-nvidia-440xx
&lt;/code>&lt;/pre>&lt;/div>&lt;p>2020年3月25日注：经过本人测试，这两步操作也可以通过系统设置里面的“硬件设定”来完成。video-nvidia-440xx仍然适用于本教程&lt;/p>
&lt;h2 id="3-修改mhwd设置">3 修改MHWD设置&lt;/h2>
&lt;p>mhwd会自动生成一些设置。这里我们需要重新手动配置，这样PRIME才能生效。&lt;/p>
&lt;h3 id="另起炉灶">另起炉灶&lt;/h3>
&lt;p>首先要删掉&lt;code>/etc/X11/xorg.conf.d/90-mhwd.conf&lt;/code>
（如果你不放心可以mv嘛。）
然后新建一个文件&lt;code>/etc/X11/xorg.conf.d/optimus.conf&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Ini" data-lang="Ini">&lt;span style="color:#50fa7b">Section &amp;#34;Module&amp;#34;&lt;/span>
&lt;span style="color:#50fa7b">Load &amp;#34;modesetting&amp;#34;&lt;/span>
&lt;span style="color:#50fa7b">EndSection&lt;/span>
&lt;span style="color:#50fa7b">Section &amp;#34;Device&amp;#34;&lt;/span>
&lt;span style="color:#50fa7b">Identifier &amp;#34;nvidia&amp;#34;&lt;/span>
&lt;span style="color:#50fa7b">Driver &amp;#34;nvidia&amp;#34;&lt;/span>
&lt;span style="color:#50fa7b">BusID &amp;#34;PCI:1:0:0&amp;#34;&lt;/span>
&lt;span style="color:#50fa7b">Option &amp;#34;AllowEmptyInitialConfiguration&amp;#34;&lt;/span>
&lt;span style="color:#50fa7b">EndSection&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意：BusID一栏需要&lt;strong>根据自己的电脑配置&lt;/strong>进行修改。BusID的值是这么查询的：&lt;code>lspci | grep -E &amp;quot;VGA|3D&amp;quot;&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;h3 id="禁用模块">禁用模块&lt;/h3>
&lt;p>PRIME依赖于&lt;code>nvidia-drm&lt;/code>，但mhwd在默认情况下会禁用它，我们需要手动启用。
此外，为了确保nvidia驱动正常开启，我们还需要禁用其他一些模块。
所以，我们需要对&lt;code>/etc/modprobe.d&lt;/code>动动手脚。&lt;/p>
&lt;p>首先，我们得把mhwd自动生成的黑名单删掉。
（译者注：不放心的话，就把后缀名改掉，因为modprobe.d里面所有conf结尾的文件都会被执行）
比如这样：&lt;strong>视情况而定，你的配置可能不同&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">ls /etc/modprobe.d/mhwd*
sudo rm /etc/modprobe.d/mhwd-gpu.conf
sudo rm /etc/modprobe.d/mhwd-nvidia.conf
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后我们要新建一个黑名单，屏蔽一些其他的模块。
新建一个文件，什么名字都可以，conf结尾就行
写入：&lt;code>/etc/modprobe.d/nvidia.conf&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Ini" data-lang="Ini">&lt;span style="color:#50fa7b">blacklist nouveau&lt;/span>
&lt;span style="color:#50fa7b">blacklist nvidiafb&lt;/span>
&lt;span style="color:#50fa7b">blacklist rivafb&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="4-开启-modeset">4 开启 modeset&lt;/h2>
&lt;p>创建一个新文件，&lt;code>/etc/modprobe.d/nvidia-drm.conf&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Ini" data-lang="Ini">&lt;span style="color:#50fa7b">options nvidia_drm modeset&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="5-设置启动脚本">5 设置启动脚本&lt;/h2>
&lt;p>我们要设置一下桌面环境的输出源。这是最难的部分，可能会花掉很长时间。
如果你现在重启，桌面环境的输出可能会有一些问题。&lt;/p>
&lt;p>我们需要写一个启动脚本，让桌面环境加载的时候能够正确选择输出源。&lt;/p>
&lt;blockquote>
&lt;p>注意，视你的具体环境（DM）执行下列的某一个步骤，不要执行所有步骤。&lt;/p>
&lt;/blockquote>
&lt;hr />
&lt;p>&lt;strong>针对 LightDM (xfce默认)&lt;/strong>
创建一个文件，&lt;code>/usr/local/bin/optimus.sh&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#ff79c6">#!/bin/sh
&lt;/span>&lt;span style="color:#ff79c6">&lt;/span>
xrandr --setprovideroutputsource modesetting NVIDIA-0
xrandr --auto
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后按照国际惯例（hhh），让它可写可执行：&lt;code>chmod a+rx /usr/local/bin/optimus.sh&lt;/code>
现在你还得把它设置为启动脚本。
编辑&lt;code>/etc/lightdm/lightdm.conf&lt;/code>，然后在**[Seat:* ]**这一节设置
&lt;code>display-setup-script=/usr/local/bin/optimus.sh&lt;/code>&lt;/p>
&lt;hr />
&lt;p>&lt;strong>针对 GDM (Gnome默认)&lt;/strong>&lt;/p>
&lt;p>创建一个文件&lt;code>/usr/local/share/optimus.desktop&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Ini" data-lang="Ini">&lt;span style="color:#ff79c6">[Desktop Entry]&lt;/span>
&lt;span style="color:#50fa7b">Type&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">Application&lt;/span>
&lt;span style="color:#50fa7b">Name&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">Optimus&lt;/span>
&lt;span style="color:#50fa7b">Exec&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">sh -c &amp;#34;xrandr --setprovideroutputsource modesetting NVIDIA-0; xrandr --auto&amp;#34;&lt;/span>
&lt;span style="color:#50fa7b">NoDisplay&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">true&lt;/span>
&lt;span style="color:#50fa7b">X-GNOME-Autostart-Phase&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">DisplayServer&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>(Exec处也可以替换成一个脚本，写一个就像LightDM里面一样的脚本)&lt;br />
然后建立连接，让它随着GDM启动。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">sudo ln -s /usr/local/share/optimus.desktop /usr/share/gdm/greeter/autostart/optimus.desktop
sudo ln -s /usr/local/share/optimus.desktop /etc/xdg/autostart/optimus.desktop
&lt;/code>&lt;/pre>&lt;/div>&lt;hr />
&lt;p>&lt;strong>针对 SDDM (KDE 默认)&lt;/strong>&lt;/p>
&lt;p>创建一个文件：&lt;code>/usr/share/sddm/scripts/Xsetup&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#ff79c6">#!/bin/sh
&lt;/span>&lt;span style="color:#ff79c6">&lt;/span>
xrandr --setprovideroutputsource modesetting NVIDIA-0
xrandr --auto
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后用chmod让它变为可执行的文件。&lt;/p>
&lt;h2 id="6-最后的工作">6 最后的工作&lt;/h2>
&lt;p>译者注：如果以上的工作都已经完成，我建议你再做一步。
我当时没有做这一步，之后重启发现内核模块加载错误。
所以还是建议，编译一下内核。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">sudo mkinitcpio -P linux
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后重启，大功告成。&lt;/p>
&lt;h2 id="验证是否成功">验证是否成功&lt;/h2>
&lt;p>如果以上你都设置正确了，当你重启之后，可以敲&lt;code>glxinfo | grep -i vendor&lt;/code>
然后看看是不是像下面这样的信息。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ glxinfo | grep -i vendor
server glx vendor string: NVIDIA Corporation
client glx vendor string: NVIDIA Corporation
OpenGL vendor string: NVIDIA Corporation
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果是，说明你已经设置成功，可以欢呼了！
&lt;em>当然我有双显示器，一看显示器亮了就知道了2333&lt;/em>&lt;/p>
&lt;h1 id="最后">最后&lt;/h1>
&lt;p>&lt;a href="https://www.v2ex.com/t/526544">这个奇怪的问题（点击查看）&lt;/a>当时也困扰了我很久
打开任务管理器没有任何占用，为啥还是一卡一卡的？
后来才知道，噢，原来是双显卡的坑。
听说最近19H1来了？反正我不想用Windows了。
自从Windows 7 之后我就没用过没bug的系统！&lt;/p>
&lt;p>希望我的这篇博文能帮到各位看官。 :)
新开的评论区(Gitment)，有问题可以在下面留言哦。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;p>&lt;a href="https://archived.forum.manjaro.org/t/howto-set-up-prime-output-offload-with-nvidia-proprietary-driver/40225">How To Set up PRIME with NVIDIA proprietary driver&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://wiki.archlinux.org/index.php/NVIDIA_Optimus">Optimus - ArchWiki&lt;/a>&lt;/p>
&lt;h2 id="github-评论区">GitHub 评论区&lt;/h2>
&lt;p>本站评论区改为 Valine, 原评论区请&lt;a href="https://github.com/AmazingRise/amazingrise.github.io/issues/1">移步至此&lt;/a>.&lt;/p>
- https://risehere.net/posts/manjaro-optimus-dual-monitor/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item></channel></rss>