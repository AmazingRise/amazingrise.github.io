<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>左手的世界</title><link>https://risehere.net/</link><description>Recent content on 左手的世界</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><copyright>Rise. 本站遵循 CC-BY-NC 4.0 协议</copyright><lastBuildDate>Fri, 25 Oct 2019 23:46:42 +0000</lastBuildDate><atom:link href="https://risehere.net/index.xml" rel="self" type="application/rss+xml"/><item><title>如何把 C 语言移植到 RISC-V 裸机上</title><link>https://risehere.net/posts/running-c-program-on-bare-machine/</link><pubDate>Thu, 14 Jan 2021 20:04:40 +0800</pubDate><guid>https://risehere.net/posts/running-c-program-on-bare-machine/</guid><description>左手的世界 https://risehere.net/posts/running-c-program-on-bare-machine/ -&lt;h1 id="前言">前言&lt;/h1>
&lt;p>之前用 Verilog 模拟实现了一个简易的 RISC-V 处理器（RV32I 指令集）。为了跑测试程序，我们的这个处理器自然也要带上存储器，所以实际上它是一台简单的计算机。为了简化设计，这台计算机基于&lt;a href="https://en.wikipedia.org/wiki/Harvard_architecture">哈佛架构&lt;/a>。简单来说，就是数据和指令分开存储，机器读取。想要运行程序，就要把汇编代码编译出来，烧写到我们的 ROM 上。&lt;/p>
&lt;p>为了方便调试，我对 CPU 进行了一些简单的约定：&lt;/p>
&lt;ul>
&lt;li>外界可以通过8个二进制开关对计算机输入一个值。这个值可以在内存地址 &lt;code>0x40000000&lt;/code> 处读取到。&lt;/li>
&lt;li>8个 LED 灯与内存地址 &lt;code>0x80000000&lt;/code> 上的值相绑定。也就是这里的值，将会以二进制的形式显示在 8 个 LED 灯上。&lt;/li>
&lt;li>处理器加电时会产生 RST 信号。寄存器收到 RST 信号时，所有的寄存器将会被置零。这个约定是为了方便初始化寄存器。&lt;/li>
&lt;/ul>
&lt;p>我们的目标是在我们的 RISC-V 计算机上成功运行一个 Fibonacci 数运算程序。流程是：&lt;/p>
&lt;ol>
&lt;li>拨动8个开关，作为输入。&lt;/li>
&lt;li>给板子加电。&lt;/li>
&lt;li>Fibonacci 运算程序从 &lt;code>0x40000000&lt;/code> 处读取8位开关的输入。&lt;/li>
&lt;li>Fibonacci 运算程序进行计算。&lt;/li>
&lt;li>Fibonacci 运算程序将结果写到 &lt;code>0x80000000&lt;/code> 这个地址上。&lt;/li>
&lt;li>8位 LED 灯以二进制的形式显示&lt;code>0x80000000&lt;/code> 处的内容。&lt;/li>
&lt;/ol>
&lt;p>用汇编实现这个程序很轻松。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">&lt;span style="color:#50fa7b">.globl&lt;/span> __start
.globl end
&lt;span style="color:#50fa7b">.text&lt;/span>
&lt;span style="color:#8be9fd;font-style:italic">__start:&lt;/span>
&lt;span style="color:#50fa7b">lui&lt;/span> x1,&lt;span style="color:#bd93f9">0x0&lt;/span>&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> lw x10,&lt;span style="color:#bd93f9">0x40000000&lt;/span>(x0)&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>
addi x2,x0,&lt;span style="color:#bd93f9">3&lt;/span>&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> addi x5,x0,&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> blt x10,x2,end&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>
addi x1,x1,&lt;span style="color:#bd93f9">12&lt;/span>&lt;span style="color:#6272a4">; # init
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> addi x6,x0,&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> sw x6,-&lt;span style="color:#bd93f9">8&lt;/span>(x1)&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> sw x6,-&lt;span style="color:#bd93f9">4&lt;/span>(x1)&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>main:
&lt;span style="color:#50fa7b">lw&lt;/span> x3,-&lt;span style="color:#bd93f9">8&lt;/span>(x1)&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> lw x4,-&lt;span style="color:#bd93f9">4&lt;/span>(x1)&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> add x5,x3,x4&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> sw x5,&lt;span style="color:#bd93f9">0&lt;/span>(x1)&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> beq x2,x10,end&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> addi x1,x1,&lt;span style="color:#bd93f9">4&lt;/span>&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> addi x2,x2,&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> beq x0,x0,main&lt;span style="color:#6272a4">;
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>end:
&lt;span style="color:#50fa7b">sw&lt;/span> x5,&lt;span style="color:#bd93f9">0x80000000&lt;/span>(x0)&lt;span style="color:#6272a4">;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么，我们是否可以将 C 语言程序移植到这个平台上呢？&lt;/p>
&lt;p>还是交叉编译那一套&amp;ndash;借助 RISC-V 交叉编译工具链，我们可以将 C 语言程序移植到我们造的计算机上。&lt;/p>
&lt;h1 id="正文">正文&lt;/h1>
&lt;h2 id="获得工具链">获得工具链&lt;/h2>
&lt;p>我们注意到，RISC-V 工具链分为两个版本：&lt;/p>
&lt;ul>
&lt;li>Newlib 版本，所有的命令开头是&lt;code>riscv64-unknown-elf-&lt;/code>。&lt;/li>
&lt;li>Linux 版本，所有的命令开头是&lt;code>riscv64-linux-gnu-&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>那么我们应该选哪个呢？经过试验两者产生的机器码（.text部分）并无区别，但我建议选择 Newlib 版本的工具链。具体原因将在&lt;a href="#faq">后面&lt;/a>说。&lt;/p>
&lt;p>Arch Linux 用户们可以&lt;strong>直接在 AUR 上获取&lt;/strong> &lt;code>riscv64-unknown-elf-gcc&lt;/code> 和 &lt;code>riscv64-unknown-elf-newlib&lt;/code> 这两个包。安装后你将获得两个版本的工具链。&lt;/p>
&lt;p>你可以从源代码自行构建 &amp;ndash; &lt;a href="https://github.com/riscv/riscv-gnu-toolchain">RISC-V GNU Compiler Toolchain&lt;/a>。&lt;/p>
&lt;h2 id="主程序的编写">主程序的编写&lt;/h2>
&lt;p>利用 C 语言的指针操作，我们可以直接读写内存。下面是实现 Fibonacci 数计算的代码：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C" data-lang="C">&lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>(){
&lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">*&lt;/span> n; &lt;span style="color:#6272a4">// Input
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> n &lt;span style="color:#ff79c6">=&lt;/span> (&lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">*&lt;/span>) &lt;span style="color:#bd93f9">0x40000000&lt;/span>; &lt;span style="color:#6272a4">// Point input to 0x40000000
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> n1 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>;
&lt;span style="color:#8be9fd">int&lt;/span> n2 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>;
&lt;span style="color:#8be9fd">int&lt;/span> n3;
&lt;span style="color:#8be9fd">int&lt;/span> i;
&lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>; i &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> (&lt;span style="color:#ff79c6">*&lt;/span>n) &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>; &lt;span style="color:#ff79c6">++&lt;/span>i){
n3 &lt;span style="color:#ff79c6">=&lt;/span> n1 &lt;span style="color:#ff79c6">+&lt;/span> n2;
n1 &lt;span style="color:#ff79c6">=&lt;/span> n2;
n2 &lt;span style="color:#ff79c6">=&lt;/span> n3;
}
&lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">*&lt;/span> result; &lt;span style="color:#6272a4">// Output
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> result &lt;span style="color:#ff79c6">=&lt;/span> (&lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">*&lt;/span>) &lt;span style="color:#bd93f9">0x80000000&lt;/span>; &lt;span style="color:#6272a4">// Point output to 0x40000000
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">*&lt;/span>result &lt;span style="color:#ff79c6">=&lt;/span> n3; &lt;span style="color:#6272a4">// Write result to 0x40000000
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">for&lt;/span>(;;){
} &lt;span style="color:#6272a4">// Endless loop, to hold on the result
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>我们现在在为裸机编写 C 语言程序，不能引用标准库中的函数，如 printf。&lt;/li>
&lt;li>由于内存紧张，我们尽量不要用递归。&lt;/li>
&lt;li>最后要写一个死循环，相当于停机。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>现在我们的主程序已经编写完毕了，下面我们要编译它。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">riscv64-unknown-elf-gcc -c -nostdlib -march&lt;span style="color:#ff79c6">=&lt;/span>rv32i -mabi&lt;span style="color:#ff79c6">=&lt;/span>ilp32 main.c -o main.o
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>-c&lt;/code>选项是编译、汇编到目标代码，不进行链接。&lt;/li>
&lt;li>&lt;code>-nostdlib&lt;/code>告诉编译器不要把标准库编译进去。&lt;/li>
&lt;li>&lt;code>-march=rv32i -mabi=ilp32&lt;/code> 用于指定指令集架构和 ABI。&lt;/li>
&lt;/ul>
&lt;p>编译后，我们可以得到 &lt;code>main.o&lt;/code>，它是一个 ELF 文件。我们只需要 &lt;code>.text&lt;/code> 部分的机器指令，所以用 &lt;code>objcopy&lt;/code> 对它进行处理：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">riscv64-unknown-elf-objcopy -O binary -j .text main.o main.bin
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>-O binary&lt;/code> 选项用于输出纯二进制文件。&lt;/li>
&lt;li>&lt;code>-j .text&lt;/code> 是告诉它只保留 &lt;code>.text&lt;/code> 部分。&lt;/li>
&lt;/ul>
&lt;p>经过处理，生成的二进制文件只含有机器指令。但此时的程序并不能直接运行。我们用 &lt;code>objdump&lt;/code> 进行反编译，看看生成的机器码是怎么样的：&lt;/p>
&lt;pre>&lt;code>➜ riscv64-unknown-elf-objdump -D -b binary main.bin -mriscv
main.bin: file format binary
Disassembly of section .data:
0000000000000000 &amp;lt;.data&amp;gt;:
0: fd010113 addi sp,sp,-48
4: 02812623 sw s0,44(sp)
8: 03010413 addi s0,sp,48
c: 400007b7 lui a5,0x40000
...
&lt;/code>&lt;/pre>&lt;p>&lt;code>lui a5,0x40000&lt;/code> 显然对应我们代码的开头（将变量 n 指向 &lt;code>0x40000000&lt;/code>）。GCC在前面加了三条指令，而第一句就将&lt;code>sp&lt;/code>寄存器减去了48。&lt;code>sp&lt;/code>为负，程序肯定不能正常运行。&lt;/p>
&lt;blockquote>
&lt;p>这三条指令用于设置 Stack Pointer(&lt;code>sp&lt;/code>) 和 Frame Pointer(&lt;code>s0&lt;/code>)。&lt;/p>
&lt;/blockquote>
&lt;p>所以，在运行 C 语言程序之前，我们需要给 &lt;code>sp&lt;/code> 寄存器设置一个初始值。这个不难，一行汇编代码就能搞定：&lt;code>lui sp, 0x10&lt;/code>。但是这行代码怎么放，又是一个问题。&lt;/p>
&lt;h2 id="将汇编语句连接到主程序">将汇编语句连接到主程序&lt;/h2>
&lt;p>下面我们将探索三种思路：&lt;/p>
&lt;ul>
&lt;li>内联汇编&lt;/li>
&lt;li>直接用 cat 合并两个二进制文件&lt;/li>
&lt;li>用 ld 连接汇编和 C 语言程序&lt;/li>
&lt;/ul>
&lt;h3 id="内联汇编">内联汇编？&lt;/h3>
&lt;p>我们可不可以在 C 语言里内联汇编实现对 &lt;code>sp&lt;/code> 的初始化呢？答案是&lt;strong>否定&lt;/strong>的。我们在 main 的第一行加一句内联汇编：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>(){
&lt;span style="color:#ff79c6">asm&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;lui sp,0x10&amp;#34;&lt;/span>);
&lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">*&lt;/span> n; &lt;span style="color:#6272a4">// Input
&lt;/span>&lt;span style="color:#6272a4">&lt;/span> n &lt;span style="color:#ff79c6">=&lt;/span> (&lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">*&lt;/span>) &lt;span style="color:#bd93f9">0x40000000&lt;/span>; &lt;span style="color:#6272a4">// Point input to 0x40000000
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后尝试反编译，看看这句话被加到了哪里：&lt;/p>
&lt;pre>&lt;code>➜ riscv64-unknown-elf-objdump -D -b binary main.bin -mriscv
main.bin: file format binary
Disassembly of section .data:
0000000000000000 &amp;lt;.data&amp;gt;:
0: fd010113 addi sp,sp,-48
4: 02812623 sw s0,44(sp)
8: 03010413 addi s0,sp,48
c: 00010137 lui sp,0x10
10: 400007b7 lui a5,0x40000
...
&lt;/code>&lt;/pre>&lt;p>可以看到，内联汇编被放在了&lt;code>0xc&lt;/code>的位置，在设置栈顶指针之后才被调用。很显然这是&lt;strong>马后炮&lt;/strong>。我们要换一种方法。&lt;/p>
&lt;h3 id="方法1-用-cat-合并">方法1 用 cat 合并&lt;/h3>
&lt;p>我们先写一个汇编文件，命名为&lt;code>init.s&lt;/code>。内容如下&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">&lt;span style="color:#50fa7b">lui&lt;/span> sp, &lt;span style="color:#bd93f9">0x10&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后我们用相同的方法编译它，并把它剪切成纯二进制格式：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">riscv64-unknown-elf-gcc -c -nostdlib -march&lt;span style="color:#ff79c6">=&lt;/span>rv32i -mabi&lt;span style="color:#ff79c6">=&lt;/span>ilp32 init.s -o init.o
riscv64-unknown-elf-objcopy -O binary -j .text init.o init.bin
&lt;/code>&lt;/pre>&lt;/div>&lt;p>再对&lt;code>init.bin&lt;/code>进行反编译，我们可以看到：&lt;/p>
&lt;pre>&lt;code>➜ riscv64-unknown-elf-objdump -D -b binary init.bin -mriscv
init.bin: file format binary
Disassembly of section .data:
0000000000000000 &amp;lt;.data&amp;gt;:
0: 00010137 lui sp,0x10
&lt;/code>&lt;/pre>&lt;p>汇编生成的机器码没有任何问题，它只含有一句话。我们用 &lt;code>cat&lt;/code> 将 &lt;code>init.bin&lt;/code> 附到 &lt;code>main.bin&lt;/code> 前面（注意调用顺序）：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">cat init.bin main.bin &amp;gt; final_cat.bin
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到我们生成了 &lt;code>final_cat.bin&lt;/code>。对它进行反编译，我们可以看到：&lt;/p>
&lt;pre>&lt;code>➜ riscv64-unknown-elf-objdump -D -b binary final_cat.bin -mriscv
final_cat.bin: file format binary
Disassembly of section .data:
0000000000000000 &amp;lt;.data&amp;gt;:
0: 00010137 lui sp,0x10
4: fd010113 addi sp,sp,-48 # 0xffd0
8: 02812623 sw s0,44(sp)
c: 03010413 addi s0,sp,48
...
&lt;/code>&lt;/pre>&lt;p>我们的&lt;code>lui sp,0x10&lt;/code>被成功加到了最前面。此时将 &lt;code>final_cat.bin&lt;/code> 烧录进 ROM，可以看到程序&lt;strong>正常运行&lt;/strong>。&lt;/p>
&lt;p>总结一下，用 cat 合并的步骤是：&lt;/p>
&lt;ol>
&lt;li>分别编写 C 语言部分和汇编部分，编译后剪成纯二进制格式&lt;/li>
&lt;li>用 cat 将两个 binary 合并在一起，注意顺序。&lt;/li>
&lt;li>烧录，运行。&lt;/li>
&lt;/ol>
&lt;h3 id="方法2-用-ld-合并">方法2 用 ld 合并&lt;/h3>
&lt;p>直接缝合两个二进制文件在这个例子中没有问题，因为&lt;code>main.bin&lt;/code>里面的地址都是相对地址，在它前面加一个指令并不会导致后面的指令出问题。但是更正规的做法是用 &lt;code>ld&lt;/code> 缝合两个部分：在汇编中，我们导入 C 语言的 &lt;code>main&lt;/code> 函数，在汇编程序中调用它。&lt;/p>
&lt;p>&lt;code>init.s&lt;/code> 改写如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">&lt;span style="color:#50fa7b">.text&lt;/span>
&lt;span style="color:#50fa7b">.globl&lt;/span> main
&lt;span style="color:#50fa7b">lui&lt;/span> x2, &lt;span style="color:#bd93f9">0x00010&lt;/span>
&lt;span style="color:#50fa7b">call&lt;/span> main
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后我们编译这些源文件：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">riscv64-unknown-elf-gcc -c -nostdlib init.s init.o
riscv64-unknown-elf-gcc -c -nostdlib main.c main.o
riscv64-unknown-elf-ld -melf32lriscv -o final.o init.o main.o
riscv64-unknown-elf-objcopy -O binary final.o final_ld
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 ld 的 &lt;code>-melf32lriscv&lt;/code> 参数用于指定架构。&lt;/p>
&lt;p>我们再反编译一下结果，看一下用 ld 生成的和 cat 生成的二进制文件有什么区别：&lt;/p>
&lt;pre>&lt;code>➜ riscv64-unknown-elf-objdump -b binary -D -mriscv final_ld
final_ld: file format binary
Disassembly of section .data:
0000000000000000 &amp;lt;.data&amp;gt;:
0: 00010137 lui sp,0x10
4: 004000ef jal ra,0x8
8: fd010113 addi sp,sp,-48 # 0xffd0
c: 02812623 sw s0,44(sp)
10: 03010413 addi s0,sp,48
...
&lt;/code>&lt;/pre>&lt;p>可以看到，在&lt;code>0x4&lt;/code>的位置多了一条 &lt;code>jal ra,0x8&lt;/code>。这是 &lt;code>ld&lt;/code> 进行链接的结果。&lt;/p>
&lt;p>将程序烧录进 ROM ，运行仿真，可以看到我们的结果被正确计算：&lt;/p>
&lt;p>&lt;img src="final.png" alt="" />&lt;/p>
&lt;p>总结一下，用 ld 连接的步骤是：&lt;/p>
&lt;ol>
&lt;li>编写 C 语言部分，编译成 ELF 文件。&lt;/li>
&lt;li>编写汇编语言部分，它负责初始化栈顶指针。也编译成 ELF 文件。&lt;/li>
&lt;li>用 ld 将两个部分连接到一起。&lt;/li>
&lt;li>连接后用 &lt;code>objcopy&lt;/code> 剪成纯二进制文件。&lt;/li>
&lt;li>烧录，运行。&lt;/li>
&lt;/ol>
&lt;h2 id="使用-makefile-自动构建">使用 Makefile 自动构建&lt;/h2>
&lt;p>无论是方法1还是方法2，编译流程都比较复杂，借用某名星的话：&lt;code>TMD 烦死了&lt;/code>。所以我们可以用 Makefile 完成编译连接剪切一整套流程：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Makefile" data-lang="Makefile">&lt;span style="color:#8be9fd;font-style:italic">CROSS_COMPILE&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>riscv64-unknown-elf-
&lt;span style="color:#8be9fd;font-style:italic">CC&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>CROSS_COMPILE&lt;span style="color:#ff79c6">)&lt;/span>gcc
&lt;span style="color:#8be9fd;font-style:italic">CFLAGS&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>-c -nostdlib -march&lt;span style="color:#ff79c6">=&lt;/span>rv32i -mabi&lt;span style="color:#ff79c6">=&lt;/span>ilp32
&lt;span style="color:#8be9fd;font-style:italic">OBJCOPY&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>CROSS_COMPILE&lt;span style="color:#ff79c6">)&lt;/span>objcopy
&lt;span style="color:#8be9fd;font-style:italic">OBJCOPYFLAGS&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>-O binary -j .text
&lt;span style="color:#8be9fd;font-style:italic">LD&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>CROSS_COMPILE&lt;span style="color:#ff79c6">)&lt;/span>ld
&lt;span style="color:#8be9fd;font-style:italic">LDFLAGS&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>-melf32lriscv
&lt;span style="color:#50fa7b">all&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> main.o init.o
&lt;span style="color:#ff79c6">$(&lt;/span>LD&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">$(&lt;/span>LDFLAGS&lt;span style="color:#ff79c6">)&lt;/span> -o final.o init.o main.o
&lt;span style="color:#ff79c6">$(&lt;/span>OBJCOPY&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">$(&lt;/span>OBJCOPYFLAGS&lt;span style="color:#ff79c6">)&lt;/span> final.o final
&lt;span style="color:#50fa7b">main.o&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> main.c
&lt;span style="color:#ff79c6">$(&lt;/span>CC&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">$(&lt;/span>CFLAGS&lt;span style="color:#ff79c6">)&lt;/span> main.c -o main.o
&lt;span style="color:#50fa7b">init.o&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> init.s
&lt;span style="color:#ff79c6">$(&lt;/span>CC&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">$(&lt;/span>CFLAGS&lt;span style="color:#ff79c6">)&lt;/span> init.s -o init.o
&lt;span style="color:#50fa7b">clean&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
rm -f *.o
rm -f *.bin
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="faq">FAQ&lt;/h1>
&lt;h2 id="newlib-和-linux-的工具链有什么区别">Newlib 和 Linux 的工具链有什么区别&lt;/h2>
&lt;p>Newlib 是不带 Glibc 的，也不支持动态链接。&lt;/p>
&lt;p>这两个工具链生成的 ELF 文件略有区别。下面是 Linux 工具链生成的 ELF文件，我们对其 objdump：&lt;/p>
&lt;pre>&lt;code>➜ riscv64-linux-gnu-objdump -x fibl
fibl: file format elf32-littleriscv
fibl
architecture: riscv:rv32, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x000100b8
Program Header:
LOAD off 0x00000000 vaddr 0x00010000 paddr 0x00010000 align 2**12
filesz 0x000001a0 memsz 0x000001a0 flags r-x
NOTE off 0x00000094 vaddr 0x00010094 paddr 0x00010094 align 2**2
filesz 0x00000024 memsz 0x00000024 flags r--
STACK off 0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4
filesz 0x00000000 memsz 0x00000000 flags rw-
Sections:
Idx Name Size VMA LMA File off Algn
0 .note.gnu.build-id 00000024 00010094 00010094 00000094 2**2
CONTENTS, ALLOC, LOAD, READONLY, DATA
1 .text 000000e8 000100b8 000100b8 000000b8 2**2
CONTENTS, ALLOC, LOAD, READONLY, CODE
2 .comment 00000012 00000000 00000000 000001a0 2**0
CONTENTS, READONLY
SYMBOL TABLE:
no symbols
&lt;/code>&lt;/pre>&lt;p>下面是 Newlib 工具链生成的 ELF 文件的 objdump 结果：&lt;/p>
&lt;pre>&lt;code>➜ riscv64-unknown-elf-objdump -x fibu
fibu: file format elf32-littleriscv
fibu
architecture: riscv:rv32, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00010054
Program Header:
LOAD off 0x00000000 vaddr 0x00010000 paddr 0x00010000 align 2**12
filesz 0x0000013c memsz 0x0000013c flags r-x
Sections:
Idx Name Size VMA LMA File off Algn
0 .text 000000e8 00010054 00010054 00000054 2**2
CONTENTS, ALLOC, LOAD, READONLY, CODE
1 .comment 00000022 00000000 00000000 0000013c 2**0
CONTENTS, READONLY
2 .riscv.attributes 0000001c 00000000 00000000 0000015e 2**0
CONTENTS, READONLY
SYMBOL TABLE:
no symbols
&lt;/code>&lt;/pre>&lt;p>可以看到，两者的差别在于 &lt;code>.note.gnu.build-id&lt;/code> 和 &lt;code>.riscv.attributes&lt;/code> 这两个部分。不过这些都是无关的注释信息。我们再用 &lt;code>objcopy&lt;/code> 把 ELF 文件处理一下，只保留 &lt;code>.text&lt;/code> 部分。可以看到，生成的纯二进制文件是一样的。&lt;/p>
&lt;p>因为我们只需要&lt;code>.text&lt;/code>部分的机器码，并且我们的程序也不涉及动态链接的问题。所以在这个代码上，用这两个工具链并无实质上的区别。不过我仍然推荐 &lt;code>Newlib&lt;/code> 版本的工具链，因为它只有静态编译，更适合嵌入式编程这个场景。&lt;/p>
&lt;h2 id="32位的处理器为什么要用-riscv64-的工具链">32位的处理器为什么要用 riscv64 的工具链&lt;/h2>
&lt;p>这个问题我也注意到了。在一些老的文章，例如这篇&lt;a href="https://five-embeddev.com/toolchain/2019/06/26/gcc-targets/">RISC-V Compile Targets, GCC&lt;/a>，里面会提到&lt;code>riscv32-&lt;/code>开头的工具链。但实际上现在的 &lt;code>riscv64&lt;/code> 工具链已经包含了 32 位支持：&lt;/p>
&lt;blockquote>
&lt;p>Yeah, that confused me too. The riscv toolchain is a little funny in that way. Upstream recommends you just build the riscv64-unknown-elf-gcc and then compile with -march=rv32i -mabi=ilp32 (or whatever suits your platform).&lt;/p>
&lt;/blockquote>
&lt;p>来源：&lt;a href="https://aur.archlinux.org/packages/riscv64-unknown-elf-gcc/">AUR 上的讨论&lt;/a>。&lt;/p>
&lt;h2 id="直接用-cat-合并不用担心重定位的问题吗">直接用 cat 合并，不用担心重定位的问题吗&lt;/h2>
&lt;p>不用。因为所有的跳转都基于相对地址。&lt;/p>
&lt;p>反编译可以发现，cat 缝合的二进制，在 0x2c 处有一句&lt;code>j 0x5c&lt;/code>。同样的代码出现在 ld 版本的 0x30 处，并且变成了 &lt;code>j 0x60&lt;/code>。但它们的机器码是一样的，都是&lt;code>0x0300006F&lt;/code>。所以用 cat 在 &lt;code>main.bin&lt;/code> 前面加一万句话都没事。&lt;/p>
&lt;p>我用两种方法都编译了一次，发现 &lt;code>ld&lt;/code> 生成和 &lt;code>cat&lt;/code> 直接缝合的两个二进制程序，实际上只差了一句 &lt;code>jal ra,0x8&lt;/code>。这句是调用约定，不过我们的 &lt;code>main&lt;/code> 函数并不需要返回，所以无所谓啦。&lt;/p>
&lt;h2 id="内存大小的问题">内存大小的问题&lt;/h2>
&lt;p>我们在这里规定的栈顶指针初始值是&lt;code>0x10000&lt;/code>。请根据你的实际内存大小进行修改。&lt;/p>
&lt;p>如果你有兴趣进行综合，那么一定要注意，有些板子的内存是不够的，例如 EGO-1。但 Minisys 好像是可以的。&lt;/p>
&lt;h1 id="最后">最后&lt;/h1>
&lt;p>在写文章的过程中，发现自己之前是误打误撞做出来的，能跑起来纯属瞎猫碰上死耗子。这个文章写了一整天，人都快没了，已经被机器码恶心死了（bushi&lt;/p>
&lt;p>在编写过程中参考了以下资料：&lt;/p>
&lt;p>&lt;a href="http://crva.ict.ac.cn/documents/RISC-V-Reader-Chinese-v2p1.pdf.11.3">RISC-V 中文手册&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.cs.cornell.edu/courses/cs3410/2019sp/riscv/interpreter/">RISC-V Online Interpreter&lt;/a> （十分推荐，可以在线运行 RISC-V 汇编指令）&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/questions/47028724/newlib-embedded-vs-desktop">StackOverflow - Newlib: embedded vs desktop&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://aur.archlinux.org/packages/riscv64-unknown-elf-gcc/">AUR (en) - riscv64-unknown-elf-gcc&lt;/a>&lt;/p>
&lt;p>另外感谢王老师提供的 CPU 讲解课程及实验器械，以及孟老师对一些问题的解答。&lt;/p>
- https://risehere.net/posts/running-c-program-on-bare-machine/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>为什么有些汉字在日语中会读成两拍</title><link>https://risehere.net/posts/checked-tone-in-japanese/</link><pubDate>Sat, 07 Nov 2020 10:45:28 +0800</pubDate><guid>https://risehere.net/posts/checked-tone-in-japanese/</guid><description>左手的世界 https://risehere.net/posts/checked-tone-in-japanese/ -&lt;h1 id="前言">前言&lt;/h1>
&lt;p>写这篇文章的动机，还要从8月说起。那天我在网上冲浪时无意间发现了“沉默”一词的最初写法应为“沈默”。我说，这一点可以在&lt;a href="https://zh.wiktionary.org/zh-hant/%E6%B2%88%E9%BB%98">日语、朝鲜语、越南语中“沈默”一词的汉字写法&lt;/a>上得到印证，并附上了一张维基字典的截图。&lt;/p>
&lt;p>此时一位师兄突然指出，日语汉字“黙”（もく，mo ku）&lt;strong>读成两拍&lt;/strong>的原因是，末尾的“く”是在&lt;strong>模拟古汉语中的“入声”&lt;/strong>。经过一番资料查找，我对日语中的“入声”终于有了点小小的认识，今分享于此。&lt;/p>
&lt;p>这篇文章不是一个严肃的研究文章，只是我对东亚文化圈中一些有趣现象的记录，大家看个乐呵就行。本文将会简单介绍日语的一些特点，以及中古汉语留下的蛛丝马迹&amp;ndash;“入声”。&lt;/p>
&lt;blockquote>
&lt;p>声明：本人并非专业的语言学研究人员，文章中如有错误，欢迎指正！&lt;/p>
&lt;/blockquote>
&lt;p>欲读懂本文：&lt;/p>
&lt;ul>
&lt;li>你需要了解日本的五十音图。不过所有的假名我都附上了罗马音，所以大概了解五十音图就可以。&lt;/li>
&lt;li>你需要对入声有一点了解，可参见&lt;a href="https://risehere.net/2019/10/27/checked-tone-in-cantonese/#%e5%85%a5%e5%a3%b0">粤语的声调与入声 - 入声&lt;/a>一节。&lt;/li>
&lt;li>另外，我用粤语拼音模拟了一下中古汉语的拼音。对于没有学过粤语的读者，可以把粤拼当作英文来读。&lt;/li>
&lt;/ul>
&lt;p>其它知识我会在文中予以补充，请大家放心食用。&lt;/p>
&lt;h1 id="正文">正文&lt;/h1>
&lt;h2 id="汉字传入日本">汉字传入日本&lt;/h2>
&lt;p>日本刚开始是没有文字的，但出于文化传播的需要，日本需要借来汉字来表达他们的语言。于是，在几百年的中日交流中，既借来了汉字用于表音（表达读音），又借来了汉字用于表意（表达意思）。这里引用《写给大家的日语史》中的一个例子：汉字“山”。&lt;/p>
&lt;ul>
&lt;li>将山的读音借来了，读作サン(sa n)。&lt;/li>
&lt;li>又让山表意，对应日语中固有（即当地人自己发明）的やま(ya ma)。即，山在这种情况下读音为やま。&lt;/li>
&lt;/ul>
&lt;p>所以，一个汉字通常有两类读法：前者被称为“音读”，后者被称为“训读”。本文的主角“入声”主要存在于&lt;strong>音读&lt;/strong>中。&lt;/p>
&lt;p>援引自维基百科，音读按照传入日本的时间，分为以下几种：&lt;/p>
&lt;ul>
&lt;li>古音：早于吴音传入日本的汉字音。源于中国上古音。&lt;/li>
&lt;li>吴音：早在公元5世纪、6世纪辗转而入的字音。&lt;/li>
&lt;li>汉音：于公元7世纪左右，日本始派出遣唐使自大唐所习得之字音。对当代日语影响最为深远。&lt;/li>
&lt;li>唐音：指宋元以后才传入日本的汉字读音，以南方口音为基准。&lt;/li>
&lt;/ul>
&lt;p>而这几次传入，中国基本都处在&lt;strong>中古汉语&lt;/strong>时期。这个时期的汉语是带有&lt;strong>入声&lt;/strong>的。而大多数入声字，在日语中都会读成两拍。下面我将说明这一现象的来龙去脉。&lt;/p>
&lt;h2 id="为什么入声读两拍">为什么入声读两拍&lt;/h2>
&lt;p>日语的音节多数为&lt;strong>开音节&lt;/strong>，意思就是读音是“辅音+元音”的结构（拨音ん和促音っ则是例外）。&lt;/p>
&lt;p>举个直观的例子，球员贝克汉姆，可以翻译成以下读音：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>汉语普通话&lt;/th>
&lt;th>粤语&lt;/th>
&lt;th>日语&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>写作&lt;/td>
&lt;td>贝克汉姆&lt;/td>
&lt;td>碧咸&lt;/td>
&lt;td>ベッカム&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>读作&lt;/td>
&lt;td>bei ke han mu&lt;/td>
&lt;td>bik ham&lt;/td>
&lt;td>Be kka mu&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>可以看到，汉语普通话和日语同为&lt;strong>开音节&lt;/strong>占优势语言，在翻译形如 ham 的音时，总要把 ha 与 m 拆开，后加一个&lt;strong>多余的元音&lt;/strong>，构成开音节。同理，日本将中古汉语带入日语时，在入声字的结尾再加入一个元音，构成一个开音节。&lt;/p>
&lt;p>这也是汉字中的一个入声字，对应到日语中有两拍的原因。&lt;/p>
&lt;p>那么这种一字对应两拍的关系，是否有固定的规律呢？答案是有的。&lt;/p>
&lt;h2 id="入声单字的一般规律">入声单字的一般规律&lt;/h2>
&lt;p>在中古汉语时期，入声主要有三种韵尾：-p，-t，-k。我们可以发现，当下文提到的入声字单独出现时，它们的音读总是&lt;strong>两拍&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>由于笔者水平有限，此处用粤语模拟中古汉语。&lt;/p>
&lt;/blockquote>
&lt;h3 id="t类">t类&lt;/h3>
&lt;p>中古汉语中的t类韵尾大多变为日语中的ち或つ。&lt;/p>
&lt;p>举例：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>粤语拼音&lt;/th>
&lt;th>假名&lt;/th>
&lt;th>罗马音&lt;/th>
&lt;th>变化规律&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>一&lt;/td>
&lt;td>yat&lt;/td>
&lt;td>いち&lt;/td>
&lt;td>i chi&lt;/td>
&lt;td>t - chi&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>節&lt;/td>
&lt;td>zit&lt;/td>
&lt;td>せつ&lt;/td>
&lt;td>se tsu&lt;/td>
&lt;td>t - tsu&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>用文字来描述，就是一(yat，或写作jat)，末尾含有入声，日语里会在末尾加个ち（chi），变成いち（i chi）。&lt;/p>
&lt;h3 id="k类">k类&lt;/h3>
&lt;p>k类韵尾大多变为く或き。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>粤语拼音&lt;/th>
&lt;th>假名&lt;/th>
&lt;th>罗马音&lt;/th>
&lt;th>变化规律&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>学&lt;/td>
&lt;td>hok&lt;/td>
&lt;td>がく&lt;/td>
&lt;td>ga ku&lt;/td>
&lt;td>k - ku&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>益&lt;/td>
&lt;td>yik&lt;/td>
&lt;td>えき&lt;/td>
&lt;td>e ki&lt;/td>
&lt;td>k - ki&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>注：益的粤拼也可写作jik。&lt;/p>
&lt;h3 id="p类">p类&lt;/h3>
&lt;p>p类入声字的结尾大多为う。例如：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>粤语拼音&lt;/th>
&lt;th>假名&lt;/th>
&lt;th>罗马音&lt;/th>
&lt;th>变化规律&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>十&lt;/td>
&lt;td>sap&lt;/td>
&lt;td>じゅう&lt;/td>
&lt;td>zyuu&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>急&lt;/td>
&lt;td>gap&lt;/td>
&lt;td>きゅう&lt;/td>
&lt;td>kyuu&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>你可能会感到很奇怪，为什么p类入声的变化和前面两个都不一样。前两个都是简单地加一个元音构成开音节，而这个ゅう看起来一点都不像p变化过来的。&lt;/p>
&lt;p>实际上，最早p类入声字对应的是ふ。最早“急”的读音是“きふ”（按当时的读音写作罗马音应为 ki pu）。后面经历了“ハ行転呼”， 所有的ipu结尾的读音都经历了这个变化：&lt;/p>
&lt;blockquote>
&lt;p>ipu → ifu → iu → yuu&lt;/p>
&lt;/blockquote>
&lt;p>具体可以参见&lt;a href="https://zh.wikipedia.org/zh-cn/%E3%83%8F%E8%A1%8C%E8%BD%89%E5%91%BC">维基百科&lt;/a>，以及&lt;a href="https://www.zhihu.com/question/264132123">这篇知乎问题&lt;/a>。&lt;/p>
&lt;h2 id="入声字组词时">入声字组词时&lt;/h2>
&lt;p>如果入声字的后面再加一个字，可能会有两种情况：&lt;/p>
&lt;ul>
&lt;li>入声字的读音不变。&lt;/li>
&lt;li>入声字变为促音。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>促音，写作っ。在日语中要在促音出现的地方停顿一下。如きぷ（ki pu）占两拍，加入促音的きっぷ（kippu）占三拍，中间暂停一拍，读起来像是ki（空）pu。罗马音里用双写来表示。&lt;/p>
&lt;/blockquote>
&lt;p>这两种情况的具体解释写在《基于优选论对日语汉字词中促音化现象的分析》论文中（完整来源见结尾）。但在此处我只作&lt;strong>最简单的归纳&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>如果这个入声字后面的字的辅音是&lt;strong>冲突&lt;/strong>的，例如：学（がく，gaku）校（こう，kou）一词中，学的韵尾k与校的起始部分k是相同的，此处应该用促音，&lt;strong>省略&lt;/strong>掉“学”的&lt;strong>韵尾&lt;/strong>变为&lt;strong>促声&lt;/strong>。がく、こう（gaku kou）变为がっこう（ga kko）。&lt;/li>
&lt;li>如果不冲突，例如“学派”，がく和は，则可以直接结合，不需要变为促音。&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>第一个字&lt;/th>
&lt;th>第二个字&lt;/th>
&lt;th>假名写作&lt;/th>
&lt;th>罗马音&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>学（がく，gaku）&lt;/td>
&lt;td>校（こう，kou）&lt;/td>
&lt;td>がっこう&lt;/td>
&lt;td>ga kko&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>学（がく，gaku）&lt;/td>
&lt;td>派（は，ha）&lt;/td>
&lt;td>がくは&lt;/td>
&lt;td>ga ku ha&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>值得注意的是，虽然p尾的入声字在日语中的结尾早已由ふ变为う，但在组词时它仍被看作ふ结尾。例如：十分 - じっぷん (zi ppun)。&lt;/p>
&lt;h1 id="后记">后记&lt;/h1>
&lt;p>写这篇文章花费了不少精力。同时，我也感到了语言的博大精深。这篇文章也只是一个浅谈，更深层的规律则要参考专业人士的论文。&lt;/p>
&lt;p>另外，不得不肯定宗教在文化传播方面的重要作用。毕竟这方面最早的研究，叫作&lt;strong>悉昙学&lt;/strong>。&lt;/p>
&lt;p>日语吸收了汉字，但又没有全盘接受。他们吸收得恰到好处&amp;ndash;既保留了汉字的特征，又服从了日语的音韵特点。最后，我想以 BYVoid 大佬的一段话作结尾（源自&lt;a href="https://byvoid.com/zht/blog/4-years-at-google-5/">这里&lt;/a>）。&lt;/p>
&lt;blockquote>
&lt;p>日本是一個熟悉而又陌生的國度。熟悉之處在於日本深受中國古典文化的影響，近代至今則反過來向中國輸出了大量文化。陌生之處在於，相比漢字文化圈的朝鮮半島和越南，日本對中國文化的吸收總是有分寸。這種感覺日本文化中隱隱約約有大唐遺風，但又絕對不是另一個「小中華」。&lt;/p>
&lt;/blockquote>
&lt;h1 id="参考">参考&lt;/h1>
&lt;ol>
&lt;li>《写给大家的日语史》（日语版「日本語の歷史」） 作者：山口仲美&lt;/li>
&lt;li>《日语概说》 作者：皮细庚&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E9%9F%B3%E8%AE%80">音读 - 维基百科&lt;/a>&lt;/li>
&lt;li>石晨.从中古汉语入声字看日语汉字词中的促音[J].日语学习与研究,2016(01):72-78.&lt;/li>
&lt;li>薛华民.基于优选论对日语汉字词中促音化现象的分析[J].教育现代化,2018,5(31):153-158.&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/264132123">在古汉语里，「急」字为入声，可为何在日语里的音读却为「きゅう」？&lt;/a>&lt;/li>
&lt;/ol>
- https://risehere.net/posts/checked-tone-in-japanese/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>古墓丽影考古记</title><link>https://risehere.net/posts/tomb-raider/</link><pubDate>Tue, 11 Aug 2020 08:42:26 +0800</pubDate><guid>https://risehere.net/posts/tomb-raider/</guid><description>左手的世界 https://risehere.net/posts/tomb-raider/ -&lt;h1 id="前言">前言&lt;/h1>
&lt;p>近几日网络不太好，玩 CSGO 都能卡成 &lt;code>Counter Strike: Microsoft PowerPoint&lt;/code>。于是我打算下载个单机游戏，正好前几天在 Steam 里白嫖到了 &lt;code>Tomb Raider&lt;/code>。（等等党の勝利）&lt;/p>
&lt;p>这个游戏在 Steam 里就叫 &lt;code>Tomb Raider&lt;/code> ，我差点以为是 1996 年的那个第一代作品。后来看了一下发行时间，推测出应该是 9 代作品。那么 7 年前的游戏会不会很老套呢？&lt;/p>
&lt;h1 id="正文">正文&lt;/h1>
&lt;h2 id="中规中矩">中规中矩&lt;/h2>
&lt;p>古墓丽影讲的故事中规中矩。换句话说，是一个很老套的西方个人英雄主义故事。游戏难度也不是特别大。&lt;/p>
&lt;ul>
&lt;li>劳拉带有主角光环，能在危楼临立之中反复横跳，如履平地，并且在经历了&lt;code>狂风暴雨&lt;/code>、&lt;code>山崩地陷&lt;/code>、&lt;code>千军万马&lt;/code>、&lt;code>兵临城下&lt;/code>、&lt;code>熊熊大火&lt;/code>、&lt;code>高山蹦极&lt;/code>等极限运动之后依旧安然无恙。&lt;/li>
&lt;li>主角没有血条，只要没有连续伤害就能活（作死跳崖不算）。所以被敌人打得快残的时候，只要苟一会就能原地满血。&lt;/li>
&lt;li>劳拉身负重伤还能活蹦乱跳，伤口浸在污水里仍然大丈夫，丝毫不惧破伤风。&lt;/li>
&lt;li>而有些地方的敌人会选择性失明、失聪。甚至劳拉在武士们头上过独木桥，在墙边上爬，也没有被发现。不过也似乎解释得通：这些日本武士已经活了上千年了，眼神不好使也正常（雾）。&lt;/li>
&lt;li>就算死了，也能从存档点复活。并且随时随地都能存档。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="20200810103931_1.jpg" alt="" />&lt;/p>
&lt;p>难道这个游戏真的是一款老掉牙的过气游戏吗？&lt;/p>
&lt;h2 id="制作精良">制作精良&lt;/h2>
&lt;p>当然不是。它的制作之精良甚至令人叹为观止。现在也是。&lt;/p>
&lt;h3 id="林深见鹿-飞泉碧峰">林深见鹿 飞泉碧峰&lt;/h3>
&lt;p>在游戏里的第二天早上，天晴了，劳拉在营地醒来，破败的荒岛深林居然也开始浮现出勃勃生机。发了一把弓，需要用它射动物。虽然说这事有点残忍，但主角作为幸存者，要恰饭的嘛。&lt;/p>
&lt;p>这个游戏的射击手感非常棒，在完成第一个任务的时候居然会有一种“在玩休闲打猎游戏”的错觉。小溪潺潺，鹿鸣呦呦，&lt;del>完全不是一个冒险游戏该有的样子。&lt;/del> （啊说到这个，通关之后我还去林子里继续打了一会猎来着，真的上瘾。）&lt;/p>
&lt;h3 id="运镜巧妙-画幅宏伟">运镜巧妙 画幅宏伟&lt;/h3>
&lt;p>除此之外，游戏对于构图和运镜也十分考究。有一幕是，劳拉需要爬无线电塔，向紧急电台发送求救信号。这时，镜头渐渐拉远，天空中微微飘着雪，苍茫的大地在屏幕里无限延伸，与渺小的劳拉形成了鲜明的对比。突然就有一种“寄蜉蝣于天地，渺沧海之一粟”的空虚感。&lt;/p>
&lt;p>是的，在大自然面前，人就是蝼蚁一般的存在。&lt;del>随后过来救援的直升机就被雷电击中了。&lt;/del>&lt;/p>
&lt;p>&lt;img src="20200809203835_1.jpg" alt="" />&lt;/p>
&lt;p>下图打败最终 BOSS 的视角。圣洁的光，照在了大地上（雾）&lt;/p>
&lt;p>&lt;img src="20200810173422_1.jpg" alt="" />&lt;/p>
&lt;p>还有另外几处攀爬地点，在经过这些地点时，镜头也会自动拉到一个合适的角度，不会使人产生眩晕感。并且这种手法和电影运镜很相似，让人有一种在看大片的感觉，体验极佳。&lt;/p>
&lt;h3 id="宝物瑰丽-建筑精美">宝物瑰丽 建筑精美&lt;/h3>
&lt;p>失落的日本邪马台（虚构）古文明究竟是什么样子？我们不曾得知。但游戏制作方从各个角度呈现出了古老帝国曾经的辉煌。&lt;/p>
&lt;p>邪马台的宫殿历经风霜雨雪，仍旧矗立在这个荒岛上，宏伟而壮观。&lt;/p>
&lt;p>&lt;img src="20200809214307_1.jpg" alt="" />&lt;/p>
&lt;p>这里也有辉煌的大型古代墓穴，在地下甚至有高耸的楼阁，和一幅幅精美而巨大的壁画。&lt;/p>
&lt;p>&lt;img src="20200811175317_1.jpg" alt="" />&lt;/p>
&lt;p>在这里，不仅有日本的古物，他们还发现了来自中国和泰国等地的文物。说明这个古老的帝国文明和东亚各国，乃至东南亚都有过密切交流。&lt;/p>
&lt;p>仔细观察就会发现，岛上也有二战时期的一些遗留：地上的很多遗体还披着日本二战时候的军装，很多指示牌也是二战时期的，还有一个分支墓位于二战废弃实验室。从这些细节我们可以窥探出，这个岛曾经是一个重要的军事基地。但遗憾的是，游戏未能在此展开。&lt;/p>
&lt;p>（有一说一，那个二战废弃实验室的分支墓居然是古风，给人一种风马牛不相及的感觉。）&lt;/p>
&lt;h3 id="开放世界-永不止步">开放世界 永不止步&lt;/h3>
&lt;p>这个游戏是开放世界游戏。在完成主线结局后，你可以继续在岛上完成剩余部分的探索。不过这个在现在已经不是什么亮点了，在此游戏发售之前就有很多开放世界游戏了。&lt;/p>
&lt;p>刚开始我是打算先粗略通关一次，分支留着下次再仔细打。没想到在游戏的最后，劳拉说：我可不打算回家，我还要继续探索。原来在结局后还能继续探索！令我有点失望的是，分支墓规模很小，开到最后也只有一个宝箱。&lt;/p>
&lt;p>&lt;img src="20200811180704_1.jpg" alt="" />&lt;/p>
&lt;p>另外，这个游戏还支持联机，而且有多种模式，看来制作组野心不小。它作为 FPS 手感还真说得过去，不过它一直不温不火，我认为是有些遗憾的。&lt;/p>
&lt;h3 id="主角好看-真的好看">主角好看 真的好看&lt;/h3>
&lt;p>主角是真的好看，这我就不必多说了，你们自己下载一个就知道了，2333。（不会编了）&lt;/p>
&lt;p>&lt;img src="20200810173600_1.jpg" alt="" />&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;h2 id="对游戏的结语">对游戏的结语&lt;/h2>
&lt;p>任何事物不可能做到完美，它也有一些缺点。文章刚开始的时候说的难度低，虽然有很多人吐槽，但也算是可以理解的：因为如果游戏过难，就不容易突出它的故事性了。除此之外，它所讲的故事有些过于牵强，主角居然为了救一个人而使那么多人牺牲。&lt;/p>
&lt;p>不过，总体来看，还是瑕不掩瑜的，可以看出制作组在很多地方都十分用心。这款游戏在现在（2020年）来看，不算落伍。时至今日，它仍是一部可玩性很高的大作。&lt;/p>
&lt;p>如果有人问我这款游戏是否值得入手，我一定会说，值得。&lt;/p>
&lt;p>&lt;img src="20200810150442_1.jpg" alt="" />&lt;/p>
&lt;p>（就算为了看看劳拉，也不错的！）&lt;/p>
&lt;h2 id="关于本篇">关于本篇&lt;/h2>
&lt;p>写文章呢，是希望以这种方式纪念一下通关的游戏。&lt;/p>
&lt;p>这篇文章全都是五笔打出的。在练习了半年五笔后，我已经基本习惯了五笔的节奏，再也不想在电脑上用拼音输入法选字了。&lt;/p>
&lt;p>同时，写这篇文章花了我一天多时间，加班加点赶出来。因为我害怕时间长不写，就像前面几篇咕了的稿子一样，放久了就再也不想写了。（我现在积压了四篇，你敢信&amp;hellip;）&lt;/p>
&lt;p>本文权当抛砖引玉。大家如果有什么不同的见解，请在下方发表。欢迎交流。&lt;/p>
- https://risehere.net/posts/tomb-raider/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>粤语的声调及入声</title><link>https://risehere.net/2019/10/27/checked-tone-in-cantonese/</link><pubDate>Sat, 04 Jul 2020 00:00:00 +0000</pubDate><guid>https://risehere.net/2019/10/27/checked-tone-in-cantonese/</guid><description>左手的世界 https://risehere.net/2019/10/27/checked-tone-in-cantonese/ -&lt;blockquote>
&lt;p>本文原发于2019.10.27。今日梳理了一下文章思路，删除了一些冗余的内容，并调整了一下文章的结构。&lt;/p>
&lt;/blockquote>
&lt;h1 id="前言">前言&lt;/h1>
&lt;p>汉语读起来十分动听， 而它正是以其抑扬顿挫之语调而著名。而粤语(广州话)中很好保留了中古汉语中的一些特征，例如声调和韵尾。&lt;/p>
&lt;p>本文将要介绍粤语的声调和韵尾。由于本人并非专业研究人员。若有错误欢迎指正！&lt;/p>
&lt;blockquote>
&lt;p>注：下文所指粤语，均为广州话为代表的粤语。&lt;/p>
&lt;/blockquote>
&lt;h1 id="声调">声调&lt;/h1>
&lt;h2 id="五度标记法">五度标记法&lt;/h2>
&lt;p>为了更好地给大家介绍粤语声调，这里先引入一种记录现代汉语声调的最广泛的方法：五度标记法。五度标记法在汉语方言相关研究中大量使用。 (由&lt;a href="https://zh.wikipedia%E3%80%82org/wiki/%E8%B5%B5%E5%85%83%E4%BB%BB">赵元任先生&lt;/a>发明，他被称为汉语言学之父)&lt;/p>
&lt;p>五度标记法它标记了一个音韵的起始，中间过程(有时省略)，和结尾的音调高低。
下面我将以现代汉语普通话为例， 跟大家介绍一下五度标记法。&lt;/p>
&lt;p>现代汉语拼音方案中用一声，二声，三声，四声表示普通话中的四个音调。以这四个声调为例，我放出一张用&lt;em>五度标记法&lt;/em>标记的四个声调的图，大家先体会一下。&lt;/p>
&lt;p>&lt;img src="pinyin-tone-chart.png" alt="" />&lt;/p>
&lt;p>曲线很直观，声调越高，曲线中对应的那一点越高。而某一位置所对应的数值越高，则代表该位置的数字表示的声调越高。我们可以从图中读出，普通话中：&lt;/p>
&lt;ul>
&lt;li>一声的调值为55&lt;/li>
&lt;li>二声的调值为35&lt;/li>
&lt;li>三声的调值为214&lt;/li>
&lt;li>四声的调值为51&lt;/li>
&lt;/ul>
&lt;p>大家可以尝试用普通话大声朗读这四个字来体会一下。&lt;/p>
&lt;p>番（fan 一声）[55]，茄（qie 二声）[35]，炒（chao 三声）[214]，蛋（dan 四声）[51]。&lt;/p>
&lt;p>(感谢维基百科提供的好例子)&lt;/p>
&lt;p>我们可以看出，五度标记法的数字是有表面含义的，它们每个都代表&lt;strong>调的相对高低&lt;/strong>。而现代汉语拼音方案的数字是无表面意义的，只是&lt;strong>四种调型的序号&lt;/strong>而已。&lt;/p>
&lt;h2 id="粤语的九声六调">粤语的九声六调&lt;/h2>
&lt;p>目前最广泛的粤语拼音方案是粤拼，也就是香港语言学学会的粤语拼音方案。本文采用粤拼来标注粤语的声调。&lt;/p>
&lt;p>援引自「&lt;a href="http://input.foruto.com/ccc/jyt/005.htm">中文字元资料页&lt;/a>」的内容：&lt;/p>
&lt;blockquote>
&lt;p>粤音则由四声，发展成九种声调，分别为：「阴平」、「阴上」、「阴去」，「阳平」、「阳上」、「阳去」，「阴入」、「中入」和「阳入」。其中「阴平、阴上、阴去、阴入、中入」是阴声系，「阳平、阳上、阳去、阳入」是阳声系。阴声系的调值较高，阳声系的调值较低。&lt;/p>
&lt;/blockquote>
&lt;p>这些声调分别对应粤拼方案的1-9。不过这段话可能过于抽象。为了让大家更好理解，我们来用刚刚学的五度标记法来标识一下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>音调&lt;/th>
&lt;th>阴平&lt;/th>
&lt;th>阴上&lt;/th>
&lt;th>阴去&lt;/th>
&lt;th>阳平&lt;/th>
&lt;th>阳上&lt;/th>
&lt;th>阳去&lt;/th>
&lt;th>阴入&lt;/th>
&lt;th>中入&lt;/th>
&lt;th>阳入&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>粤拼&lt;/td>
&lt;td>1&lt;/td>
&lt;td>2&lt;/td>
&lt;td>3&lt;/td>
&lt;td>4&lt;/td>
&lt;td>5&lt;/td>
&lt;td>6&lt;/td>
&lt;td>7&lt;/td>
&lt;td>8&lt;/td>
&lt;td>9&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>五度&lt;/td>
&lt;td>55/53&lt;/td>
&lt;td>35&lt;/td>
&lt;td>33&lt;/td>
&lt;td>11/21&lt;/td>
&lt;td>13&lt;/td>
&lt;td>22&lt;/td>
&lt;td>5(5)&lt;/td>
&lt;td>3(3)&lt;/td>
&lt;td>2(2)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>我们可以看到，粤拼的数字，与现代汉语拼音方案都&lt;strong>仅仅代表某一个调型&lt;/strong>，并不代表本身声调的高低，数值本身是无意义的。&lt;/p>
&lt;p>下面附上更加直观的曲线法。(图片来自&lt;a href="http://www.cantonese.asia/portal.php?mod=view&amp;amp;aid=229">粤语协会&lt;/a>)&lt;/p>
&lt;p>&lt;img src="tone.jpg" alt="" />&lt;/p>
&lt;blockquote>
&lt;p>图中省略了7 8 9三个声调，因为它们的音高与1 3 6的起点是相同的。人们说粤语有「九声六调」（九个声调，六种音高）。至于语音学学者，则大多把「声调」直接定义作音高，不计算其顿错性，就会直接说粤语有「六个声调」。两种说法的分别，只是对「声调」定义不同而已。&lt;/p>
&lt;/blockquote>
&lt;p>有一个简单的方法，你需要找一个会广州话的人，分别读一下「三 九 四 零 五 二 七 八 六」。
这九个数字正好分别对应粤拼的1 2 3 4 5 6 7 8 9声。&lt;/p>
&lt;p>如果读者在此对于区分六个音调仍然存疑，可进入这个网站:&lt;a href="http://www.iso10646hk.net/jp/learning/course_03.jsp">香港语言学学会粤语拼音方案&lt;/a>进行音频试听。&lt;/p>
&lt;p>个人认为，对于非粤语母语者，学习粤语最准确的方法是先学习这一拼音方案。（不过多听多看是根本）&lt;/p>
&lt;h1 id="入声">入声&lt;/h1>
&lt;h2 id="简介">简介&lt;/h2>
&lt;ol>
&lt;li>入声早已消失在现代普通话(或更泛化地说，北方方言)中。但是在一些方言，例如粤语，客家话，闽南语中得以保留。&lt;/li>
&lt;li>与入声相对的是舒声。（所以普通话里面全都是舒声。）&lt;/li>
&lt;li>入声又被称为喉塞音。这种叫法很形象，可能会加快理解的过程。&lt;/li>
&lt;li>入声字的韵尾以塞音快速结束，大部分入声字听起来就像气流突然被阻断。&lt;/li>
&lt;li>然而古代汉语却有入声，时人作赋之时，有些便以入声作为韵尾。(有些诗用方言才能更好地表现出它的艺术特色。下文会举出一些例子。)&lt;/li>
&lt;/ol>
&lt;h2 id="粤语的入声">粤语的入声&lt;/h2>
&lt;p>在粤语中，入声是&lt;code>无声除阻音&lt;/code>。就是说，念到入声的时候，需要有气流的阻断这一过程，但是实际上&lt;strong>不发出声音&lt;/strong>。&lt;/p>
&lt;p>粤语中有三个入声韵尾: &lt;code>-p&lt;/code> &lt;code>-t&lt;/code> &lt;code>-k&lt;/code>。&lt;/p>
&lt;p>最早我无法区分这三个入声的区别。但在读「入」和「日」字的时候，又感觉到这两个字不太一样。&lt;/p>
&lt;ul>
&lt;li>入的粤拼是: jap6&lt;/li>
&lt;li>日的粤拼是: jat6&lt;/li>
&lt;/ul>
&lt;p>同样的区别可以体现在「八」和「百」这两个字上面。&lt;/p>
&lt;ul>
&lt;li>八: baat3&lt;/li>
&lt;li>百: baak3&lt;/li>
&lt;/ul>
&lt;p>大家可以尝试抓一个本地人，听听他们在这些字的末尾是怎么收拢嘴巴的。抓不到的话也可以在这个网站上试听：&lt;a href="http://www.iso10646hk.net/jp/database/index.jsp">粤拼资料库&lt;/a>&lt;/p>
&lt;p>简单来讲，这三个韵尾的区别在于：&lt;/p>
&lt;ol>
&lt;li>&lt;code>-p&lt;/code> 要在嘴脣处阻断气流。如 垃圾 &lt;code>laap6 saap3&lt;/code>。在两个字的结尾，要将嘴脣闭合，以阻断气流。&lt;/li>
&lt;li>&lt;code>-t&lt;/code> 要在舌尖处阻断气流。如 佛 &lt;code>fat6&lt;/code>。在佛字的结尾，要用舌尖抵住牙齿阻断气流。&lt;/li>
&lt;li>&lt;code>-k&lt;/code> 要在舌根处阻断气流。如 白色 &lt;code>baak6 sik1&lt;/code>。在白和色这两个字的结尾，要用舌根抵住硬颚和软颚交界处阻断气流。&lt;/li>
&lt;/ol>
&lt;p>如果我们用更通俗一些的方式阐述，则是:&lt;/p>
&lt;p>&lt;strong>在粤拼中遇到这三个韵尾的时候，你需要分别做出英语中 p t k 的口型来阻断气流。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>这与英语口语中的尾音略有类似。例如&lt;code>keep&lt;/code>，不可能读成 &lt;code>ki pu&lt;/code>。最后的p会很轻很轻，并且不发音。&lt;/p>
&lt;/blockquote>
&lt;h2 id="补充">补充&lt;/h2>
&lt;p>但在我阅读一些其他的粤语教程的时候，发现有的教程的入声韵尾并不是用&lt;code>-p&lt;/code> &lt;code>-t&lt;/code> &lt;code>-k&lt;/code>这三个字母标记的。有些书用&lt;code>-b&lt;/code> &lt;code>-d&lt;/code> &lt;code>-g&lt;/code>这三个字母标注韵尾。其实这些标记方法在本质上是相同的。&lt;/p>
&lt;p>因为前面说过入声在粤语中是无声除阻音，也就是不发声。而&lt;code>p-b&lt;/code>，&lt;code>t-d&lt;/code>，&lt;code>k-g&lt;/code>之间的区别在于是否送气。
由于入声不需要声带振动，所以送气和不送气辅音可以视作等同的。&lt;/p>
&lt;p>举个例子，在韵尾为p的字中，收尾的时候无论你是摆&lt;code>b&lt;/code>的口型，还是摆&lt;code>p&lt;/code>的口型，是一样的。&lt;/p>
&lt;p>不过我们还是要以最流行的粤拼方案为准。这样可以少走一些弯路。&lt;/p>
&lt;h1 id="最后">最后&lt;/h1>
&lt;p>本文为Rise原创。如果有什么不准确的地方，欢迎各位在评论区指出。&lt;/p>
&lt;p>共同传承中华文化🥳&lt;/p>
&lt;h1 id="引用">引用&lt;/h1>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/%E7%B2%A4%E8%AF%AD">粤语 on Wikipedia&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/%E4%BA%94%E5%BA%A6%E6%A0%87%E8%AE%B0%E6%B3%95">五度标记法 on Wikipedia&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://input.foruto.com/ccc/jyt/005.htm">中文字元资料页&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.cantonese.asia/portal.php?mod=view&amp;amp;aid=229">粤语协会&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.iso10646hk.net/jp/learning/course_03.jsp">香港语言学学会粤语拼音方案&lt;/a>&lt;/p>
- https://risehere.net/2019/10/27/checked-tone-in-cantonese/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item><item><title>2020年，在 Linux 下动手编译 OpenJDK 8</title><link>https://risehere.net/posts/building-openjdk/</link><pubDate>Tue, 05 May 2020 12:52:49 +0800</pubDate><guid>https://risehere.net/posts/building-openjdk/</guid><description>左手的世界 https://risehere.net/posts/building-openjdk/ -&lt;h1 id="前言">前言&lt;/h1>
&lt;p>这两天开始读深入理解 Java 虚拟机了。在这本书的第一章就提到了动手编译 OpenJDK。 &lt;del>突然想到 2018 年 11 月被 OpenCV 的交叉编译支配的恐惧。&lt;/del>&lt;/p>
&lt;p>网上的各种攻略琳琅满目，五花八门。&lt;/p>
&lt;p>终于，在蹚了前人的那些坑之后，我成功编译了 OpenJDK 8。其实编译一个 JDK 也没那么难。&lt;/p>
&lt;p>&amp;ndash; 即使是 2020 年，在更新策略&lt;strong>激进&lt;/strong>的 Arch 系 Linux 下，我没有降级任何软件也照样编译成功。&lt;/p>
&lt;blockquote>
&lt;p>注：本篇文章以 Manjaro Linux 为例进行讲解。其它的 Linux 基本一致，只是软件包名不同。&lt;/p>
&lt;/blockquote>
&lt;h1 id="准备">准备&lt;/h1>
&lt;h2 id="环境">环境&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th align="left">名称&lt;/th>
&lt;th align="left">版本&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td align="left">OS&lt;/td>
&lt;td align="left">Manjaro 20.0 Lysia&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Kernel&lt;/td>
&lt;td align="left">x86_64 Linux 4.19.118-1-MANJARO&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">make&lt;/td>
&lt;td align="left">GNU Make 4.3 x86_64-pc-linux-gnu&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">GCC&lt;/td>
&lt;td align="left">gcc (Arch Linux 9.3.0-1) 9.3.0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>注：我并没有切换到低版本的 gcc。&lt;/p>
&lt;/blockquote>
&lt;h2 id="openjdk-8">OpenJDK 8&lt;/h2>
&lt;p>你需要一个 OpenJDK 8 来编译 OpenJDK 8 原代码中的 Java 代码。太高或太低都不能编译成功。&lt;/p>
&lt;blockquote>
&lt;p>注： OpenJDK 7 理论上可以，但编译时会出问题。还是建议用 OpenJDK 8。&lt;/p>
&lt;/blockquote>
&lt;p>在 Arch Linux/Manjaro Linux 下，可以通过&lt;code>archlinux-java status&lt;/code>查看是否有 OpenJDK 8。输入以下命令：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ archlinux-java status | grep &lt;span style="color:#bd93f9">8&lt;/span>
java-8-openjdk
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果没有的话（即上面命令没有结果），赶紧去搞一个！（&lt;code>sudo pacman -S jdk8-openjdk&lt;/code>）&lt;/p>
&lt;h2 id="mercurial">Mercurial&lt;/h2>
&lt;p>作为 OpenJDK 的版本管理系统，类似于 git。&lt;/p>
&lt;p>在 Arch Linux 下可以通过 &lt;code>sudo pacman -S mercurial&lt;/code> 安装。&lt;/p>
&lt;p>（直接连接会很慢，请自行准备工具，具体工具请自行探索，支持 HTTP 代理就可以。下文会讲解如何给 mercurial 套 HTTP 代理。）&lt;/p>
&lt;blockquote>
&lt;p>注：本篇文章中提到的所有 sudo 操作都已经特别指出，不要在 sudo 模式下进行其它操作。&lt;/p>
&lt;/blockquote>
&lt;h2 id="gcc-和-make">GCC 和 make&lt;/h2>
&lt;p>这个貌似不用我多说。这个年头用 Linux 写代码，没个 &lt;code>gcc&lt;/code> 和 &lt;code>make&lt;/code> 好像还是一件挺尴尬的事情。&lt;/p>
&lt;p>（还是说一句：make 不是系统自带的，gcc 大多数自带，缺什么装什么。）&lt;/p>
&lt;h1 id="编译">编译&lt;/h1>
&lt;p>以上的工具准备好了，就可以开始编译了。&lt;/p>
&lt;h2 id="clone">clone&lt;/h2>
&lt;p>正常下载是&lt;code>hg clone 目标网址&lt;/code>。如果你的网络环境不好，可以出动 HTTP 代理。下例是让 mercurial 经过 http://127.0.0.1:8000/ 处的代理：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">hg --config http_proxy.host&lt;span style="color:#ff79c6">=&lt;/span>127.0.0.1:8000 clone http://hg.openjdk.java.net/jdk8u/jdk8u/
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="get_source">get_source&lt;/h2>
&lt;p>如果你的网络环境不好，我们要预先定义一下代理：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#8be9fd;font-style:italic">export&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">HGFOREST_GLOBALOPTS&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34; --config http_proxy.host=127.0.0.1:8000&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意：在&lt;code>--config&lt;/code>前有&lt;strong>一个空格&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;p>开始吧：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">chmod +x ./get_source.sh
./get_source.sh
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果中间失败，可以重复运行&lt;code>get_source.sh&lt;/code>，脚本会从失败的地方继续下载。&lt;/p>
&lt;blockquote>
&lt;p>注意：有些地方提到可以去 &lt;a href="http://jdk.java.net/">http://jdk.java.net/&lt;/a> 下载。但是我这里下载到的源代码都不能正常编译。&lt;/p>
&lt;/blockquote>
&lt;h2 id="configure">configure&lt;/h2>
&lt;p>输入以下命令开始配置工作。这里需要手动指定 Bootstrap JDK 的路径。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">./configure --with-boot-jdk&lt;span style="color:#ff79c6">=&lt;/span>/usr/lib/jvm/java-8-openjdk
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果没有报错，那么说明你的环境配置正常。&lt;/p>
&lt;h2 id="dirty-hack">dirty hack&lt;/h2>
&lt;p>我们还需要更改一下编译参数。OpenJDK 默认编译的时候会将所有 &lt;code>warning&lt;/code> 视为 &lt;code>error&lt;/code>，会导致以下错误：&lt;code>cc1plus: all warnings being treated as errors&lt;/code>&lt;/p>
&lt;p>因为 OpenJDK 8 的编译不支持 &lt;code>--disable-warnings-as-errors&lt;/code> 参数，所以我们需要&lt;strong>手动修改&lt;/strong>一下：&lt;/p>
&lt;p>打开&lt;code>./hotspot/make/linux/makefiles/gcc.make&lt;/code>，然后找到 &lt;code>WARNINGS_ARE_ERRORS =&lt;/code>，前面加&lt;code>#&lt;/code>，把这行&lt;strong>注释掉&lt;/strong>。&lt;/p>
&lt;h2 id="make">make&lt;/h2>
&lt;p>最后，可以正式编译了，分情况讨论。&lt;/p>
&lt;blockquote>
&lt;p>注：不需要指定 CPU 核心数。默认编译就是多核。&lt;/p>
&lt;/blockquote>
&lt;h3 id="仅编译">仅编译&lt;/h3>
&lt;p>如果只编译，不想要二进制：输入&lt;code>make&lt;/code>命令，开始编译。&lt;/p>
&lt;p>当你看到以下信息时，你就成功了：&lt;/p>
&lt;pre>&lt;code>## Finished jdk (build time 00:01:43)
----- Build times -------
Start 2020-05-05 13:14:42
End 2020-05-05 13:20:26
00:00:13 corba
00:03:23 hotspot
00:00:08 jaxp
00:00:11 jaxws
00:01:43 jdk
00:00:06 langtools
00:05:44 TOTAL
-------------------------
&lt;/code>&lt;/pre>&lt;h3 id="编译二进制">编译二进制&lt;/h3>
&lt;p>如果你想编译出 JDK JRE 的那套二进制的话，请运行&lt;code>make images&lt;/code>。&lt;/p>
&lt;p>此时结果应该是这样的：&lt;/p>
&lt;pre>&lt;code>## Finished images (build time 00:01:28)
----- Build times -------
Start 2020-05-05 19:36:50
End 2020-05-05 19:38:49
00:00:00 corba
00:00:16 demos
00:00:00 hotspot
00:01:28 images
00:00:01 jaxp
00:00:00 jaxws
00:00:05 jdk
00:00:01 langtools
00:00:08 nashorn
00:01:59 TOTAL
-------------------------
&lt;/code>&lt;/pre>&lt;p>这种情况下，你可以在&lt;code>./build/linux-x86_64-normal-server-release/images/j2sdk-image/bin/&lt;/code>目录下找到&lt;code>java&lt;/code>和&lt;code>javac&lt;/code>。&lt;/p>
&lt;p>你可以运行一下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ./java -version
openjdk version &lt;span style="color:#f1fa8c">&amp;#34;1.8.0-internal&amp;#34;&lt;/span>
OpenJDK Runtime Environment &lt;span style="color:#ff79c6">(&lt;/span>build 1.8.0-internal-amazingrise_2020_05_05_13_13-b00&lt;span style="color:#ff79c6">)&lt;/span>
OpenJDK 64-Bit Server VM &lt;span style="color:#ff79c6">(&lt;/span>build 25.71-b00, mixed mode&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>没错，它的版本号里写着你的机器名。 很有成就感。&lt;/p>
&lt;h1 id="最后">最后&lt;/h1>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>真的就这些了吗？是的，就这些。在 Linux 上，书上那一长串的&lt;code>export&lt;/code>统统不需要。&lt;/p>
&lt;p>而且可以看出，在我的普普通通的笔记本上，&lt;strong>不设置任何参数&lt;/strong>也可以很快完成编译。网上和书上的各种优化大可不必，&lt;code>configure&lt;/code>已经帮我们做好大部分了。&lt;/p>
&lt;blockquote>
&lt;p>尽信书不如无书。&lt;/p>
&lt;/blockquote>
&lt;p>有人可能会说这篇文章很水，但实际上我花了很多时间：我编译过 OpenJDK 7, 9, 11, 14，试了网上各种各样的方法都不行。&lt;/p>
&lt;p>就是希望后人少走点弯路吧（不走是不可能的）。&lt;/p>
&lt;p>另外，网上有人说，OpenJDK 8 编译巨坑，&lt;strong>其实也没那么复杂&lt;/strong>。（可能因为他是 macOS？）&lt;/p>
&lt;p>网上还有人说，怎么编译都不成功，把 Ubuntu 换成 CentOS 才行。我想说，&lt;strong>真的不至于&lt;/strong>。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>《深入理解 Java 虚拟机》周志明著，第二版。&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/desiyonan/article/details/80801991">问题整理 [已解决] - Debian10 下编译 OpenJDK-8 源码 - cc1plus: all warnings being treated as errors&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://bugs.openjdk.java.net/browse/JDK-8144695">&amp;ndash;disable-warnings-as-errors does not work for HotSpot build&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.jianshu.com/p/4e01daf8c357">osx环境编译jdk8&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/iou123lg/p/9696039.html">JVM-Ubuntu18.04.1下编译OpenJDK8&lt;/a>&lt;/p>
&lt;h2 id="次回予告">次回予告&lt;/h2>
&lt;p>下次可能是 &lt;code>NES 模拟器&lt;/code>或者&lt;code>简单 NLP 问答机器人&lt;/code>的实现了，看我有没有时间吧。&lt;/p>
- https://risehere.net/posts/building-openjdk/ - Rise. 本站遵循 CC-BY-NC 4.0 协议</description></item></channel></rss>