<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Translation on 左手的世界</title><link>https://risehere.net/tags/translation/</link><description>Recent content in Translation on 左手的世界</description><generator>Hugo</generator><language>zh-TW</language><copyright>Rise. 本站遵循 CC-BY-NC 4.0 协议</copyright><lastBuildDate>Sat, 18 May 2019 10:47:06 +0000</lastBuildDate><atom:link href="https://risehere.net/tags/translation/index.xml" rel="self" type="application/rss+xml"/><item><title>(译)Kotlin中的等号，"=="，"==="和"equals"</title><link>https://risehere.net/2019/05/18/Equality-In-Kotlin-Translation/</link><pubDate>Sat, 18 May 2019 10:47:06 +0000</pubDate><guid>https://risehere.net/2019/05/18/Equality-In-Kotlin-Translation/</guid><description>&lt;p&gt;Translated from: &lt;a href="https://medium.com/@agrawalsuneet/equality-in-kotlin-and-equals-d8373ef529f1"&gt;Equality in Kotlin&lt;/a&gt;
Author: Suneet Agrawal
Translated by : AmazingRise (Authorized by original author)&lt;/p&gt;
&lt;p&gt;在编程中，我们经常需要比较两个变量的值是否相等，或者两个对象的引用是否一致。
Kotlin语言里，“等号”有这么几种：&lt;code&gt;==&lt;/code&gt;，&lt;code&gt;===&lt;/code&gt;与&lt;code&gt;.equals&lt;/code&gt;。
那么问题来了，我们该如何正确使用这些相等性判断呢？&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;我们来一起看一看Kotlin的几种相等性判断：&lt;/p&gt;
&lt;h2 id="结构性相等-"&gt;结构性相等 (&amp;quot;==&amp;quot;)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;==&lt;/code&gt;操作符用于比较两个变量的值。
&lt;strong&gt;请不要与Java中的&lt;code&gt;==&lt;/code&gt;相混淆。&lt;/strong&gt;
与Java中的&lt;code&gt;==&lt;/code&gt;操作符&lt;strong&gt;不同&lt;/strong&gt;的是：&lt;code&gt;==&lt;/code&gt;操作符在Kotlin中只比较值。
而Java或其它语言中，&lt;code&gt;==&lt;/code&gt;通常用来比较两个对象的引用。
Kotlin中，&lt;code&gt;==&lt;/code&gt;的否定形式是&lt;code&gt;!=&lt;/code&gt;，当两个变量值不同时返回真。&lt;/p&gt;
&lt;h2 id="引用性相等"&gt;引用性相等(&amp;quot;===&amp;quot;)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;===&lt;/code&gt;操作符用于比较两个变量的引用是否一致。只有当两个变量指向同一个实例时，&lt;code&gt;===&lt;/code&gt;的值才为真。
&lt;code&gt;===&lt;/code&gt;的否定形式是&lt;code&gt;!==&lt;/code&gt;，当两个对象的引用不同的时候返回真。&lt;/p&gt;
&lt;p&gt;不过对于原始类型（Primitive type）来说（例如 Int），&lt;code&gt;=== &lt;/code&gt;等价于&lt;code&gt; ==&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id="equals-方法"&gt;.equals 方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;equals(other: Any?)&lt;/code&gt;方法是在&lt;code&gt;Any&lt;/code&gt;类里实现的。
并且所有类中&lt;code&gt;.equals&lt;/code&gt;都可以被重写（毕竟所有的类都继承于Any嘛，就像Java里的Object一样）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.equals&lt;/code&gt;方法将会比较两个变量的值。
与&lt;code&gt;==&lt;/code&gt;不同体现在比较&lt;code&gt;Float&lt;/code&gt;和&lt;code&gt;Double&lt;/code&gt;的时候，&lt;code&gt;.equals&lt;/code&gt;违背了IEEE 754 浮点数运算标准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与IEEE 754浮点数运算标准相违背，意味着什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NaN 等于它本身&lt;/li&gt;
&lt;li&gt;NaN 比任何其他元素要大，包括正无穷 &lt;code&gt;POSITIVE_INFINITY&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;编译器会认为&lt;code&gt;-0.0&lt;/code&gt; 要比 &lt;code&gt;0.0&lt;/code&gt; 小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一头雾水？&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="举个栗子"&gt;举个栗子&lt;/h2&gt;
&lt;p&gt;我来举几个例子解释一下。&lt;/p&gt;
&lt;p&gt;首先，我们用这几个方法比较两个原始类型的变量（Int）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-Kotlin" data-lang="Kotlin"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#66d9ef"&gt;val&lt;/span&gt; int1 = &lt;span style="color:#ae81ff"&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#66d9ef"&gt;val&lt;/span&gt; int2 = &lt;span style="color:#ae81ff"&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	println(int1 &lt;span style="color:#f92672"&gt;==&lt;/span&gt; int2)			&lt;span style="color:#75715e"&gt;// true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	println(int1.equals(int2))		&lt;span style="color:#75715e"&gt;// true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	println(int1 &lt;span style="color:#f92672"&gt;===&lt;/span&gt; int2)		&lt;span style="color:#75715e"&gt;// true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这三个println最后都会输出&lt;code&gt;true&lt;/code&gt;，因为对于原始类型，这三种判断都仅仅检查变量的值。
所以在这种情况下，&lt;code&gt;===&lt;/code&gt;输出的结果也是一样的。&lt;/p&gt;</description></item></channel></rss>