<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编译 on 左手的世界</title><link>https://risehere.net/categories/%E7%BC%96%E8%AF%91/</link><description>Recent content in 编译 on 左手的世界</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><copyright>Rise. 本站遵循 CC-BY-NC 4.0 协议</copyright><lastBuildDate>Thu, 14 Jan 2021 20:04:40 +0800</lastBuildDate><atom:link href="https://risehere.net/categories/%E7%BC%96%E8%AF%91/index.xml" rel="self" type="application/rss+xml"/><item><title>如何把 C 语言移植到 RISC-V 裸机上</title><link>https://risehere.net/posts/running-c-program-on-bare-machine/</link><pubDate>Thu, 14 Jan 2021 20:04:40 +0800</pubDate><guid>https://risehere.net/posts/running-c-program-on-bare-machine/</guid><description>前言 之前用 Verilog 模拟实现了一个简易的 RISC-V 处理器（RV32I 指令集）。为了跑测试程序，我们的这个处理器自然也要带上存储器，所以实际上它是一台简单的计算机。为了简化设计，这台计算机基于哈佛架构。简单来说，就是数据和指令分开存储，机器读取。想要运行程序，就要把汇编代码编译出来，烧写到我们的 ROM 上。
为了方便调试，我对 CPU 进行了一些简单的约定：
外界可以通过8个二进制开关对计算机输入一个值。这个值可以在内存地址 0x40000000 处读取到。 8个 LED 灯与内存地址 0x80000000 上的值相绑定。也就是这里的值，将会以二进制的形式显示在 8 个 LED 灯上。 处理器加电时会产生 RST 信号。寄存器收到 RST 信号时，所有的寄存器将会被置零。这个约定是为了方便初始化寄存器。 我们的目标是在我们的 RISC-V 计算机上成功运行一个 Fibonacci 数运算程序。流程是：
拨动8个开关，作为输入。 给板子加电。 Fibonacci 运算程序从 0x40000000 处读取8位开关的输入。 Fibonacci 运算程序进行计算。 Fibonacci 运算程序将结果写到 0x80000000 这个地址上。 8位 LED 灯以二进制的形式显示0x80000000 处的内容。 用汇编实现这个程序很轻松。
.globl __start .globl end .text __start: lui x1,0x0; lw x10,0x40000000(x0); addi x2,x0,3; addi x5,x0,1; blt x10,x2,end; addi x1,x1,12; # init addi x6,x0,1; sw x6,-8(x1); sw x6,-4(x1); main: lw x3,-8(x1); lw x4,-4(x1); add x5,x3,x4; sw x5,0(x1); beq x2,x10,end; addi x1,x1,4; addi x2,x2,1; beq x0,x0,main; end: sw x5,0x80000000(x0); 那么，我们是否可以将 C 语言程序移植到这个平台上呢？</description></item><item><title>2020年，在 Linux 下动手编译 OpenJDK 8</title><link>https://risehere.net/posts/building-openjdk/</link><pubDate>Tue, 05 May 2020 12:52:49 +0800</pubDate><guid>https://risehere.net/posts/building-openjdk/</guid><description>前言 这两天开始读深入理解 Java 虚拟机了。在这本书的第一章就提到了动手编译 OpenJDK。 突然想到 2018 年 11 月被 OpenCV 的交叉编译支配的恐惧。
网上的各种攻略琳琅满目，五花八门。
终于，在蹚了前人的那些坑之后，我成功编译了 OpenJDK 8。其实编译一个 JDK 也没那么难。
&amp;ndash; 即使是 2020 年，在更新策略激进的 Arch 系 Linux 下，我没有降级任何软件也照样编译成功。
注：本篇文章以 Manjaro Linux 为例进行讲解。其它的 Linux 基本一致，只是软件包名不同。
准备 环境 名称 版本 OS Manjaro 20.0 Lysia Kernel x86_64 Linux 4.19.118-1-MANJARO make GNU Make 4.3 x86_64-pc-linux-gnu GCC gcc (Arch Linux 9.3.0-1) 9.3.0 注：我并没有切换到低版本的 gcc。</description></item></channel></rss>